{"title":"Errors & Object Oriented Programming","markdown":{"yaml":{"title":"Errors & Object Oriented Programming","subtitle":"Lecture 2","author":"Jay Paul Morgan","format":{"html":"default","revealjs":{"output-file":"lecture-2-reveal.html","scrollable":true,"smaller":false,"slide-number":true,"slide-level":2,"navigation-mode":"vertical","transition":"slide"}}},"headingText":"Dealing with Errors","containsRefs":false,"markdown":"\n\n\n\nWhen programming, its good to be defensive and handle errors gracefully. For example,\nif you're creating a program, that as part of its process, reads from a file, its\npossible that this file may not exist at the point the program tries to read it. If\nit doesn't exist, the program will crash giving an error such as: `FileNotfoundError`.\n\nPerhaps this file is non-essential to the operation of the program, and we can\ncontinue without the file. In these cases, we will want to appropriately catch the\nerror to prevent it from stopping Python.\n\n## Try-catch\n\nTry-catches are keywords that introduce a scope where the statements are executed,\nand if an error (of a certain type IndexError in this example) occurs, different\nstatements could be executed.\n\nIn this example, we are trying to access an element in a list using an index larger\nthan the length of the list. This will produce an `IndexError`. Instead of exiting\nPython with an error, however, we can catch the error, and print a string.\n\n```python\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError:\n        print(\"Couldn't access element\")\n```\n\n    Results: \n    # => Couldn't access element\n\n\n## Capturing messages\n\nIf we wanted to include the original error message in the print statement, we can use\nthe form:\n\n```python\n    except <error> as <variable>\n```\n\nThis provides us with an variable containing the original error that we can use later\non in the try-catch form.\n\n```python\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError as e:\n        print(f\"Couldn't access elements at index beacuse: {e}\")\n```\n\n    Results: \n    # => Couldn't access elements at index beacuse: list index out of range\n\n\n## Types of exceptions\n\nThere are numerous types of errors that could occur in a Python. Here are just some\nof the most common.\n\n-   `IndexError` &#x2013; Raised when a sequence subscript is out of range.\n-   `ValueError` &#x2013; Raised when an operation or function receives an argument that has the right type but an inappropriate value\n-   `AssertionError` &#x2013; Raised when an assert statement fails.\n-   `FileNotFoundError` &#x2013; Raised when a file or directory is requested but doesnâ€™t exist.\n\nThe full list of exceptions in Python 3 can be found at: <https://docs.python.org/3/library/exceptions.html>\n\n\n## Assertions\n\nOne of the previous errors (`AssertionError`) occurs when an assert statement\nfails. Assert is a keyword provided to test some condition and raise an error if the\ncondition is false. It typically requires less code than an `if`-statement that raises\nan error, so they might be useful for checking the inputs to functions, for example:\n\n```python\n    def my_divide(a, b):\n        assert b != 0\n        return a / b\n    \n    my_divide(1, 2)\n    my_divide(1, 0)\n```\n\nHere we are checking that the divisor is not a 0, in which case division is not defined.\n\n\n# OOP\n\n\n## Introduction to classes\n\nA class is some representation (can be abstract) of an object. Classes can be used to\ncreate some kind of structure that can be manipulated and changed, just like the ways\nyou've seen with lists, dictionaries, etc.\n\nClasses allow us to perform Object-oriented Programming (OOP), where we represent\nconcepts by classes.\n\nBut to properly understand how classes work, and why we would want to use them, we\nshould take a look at some examples.\n\n\n## Basic syntax\n\nWe're going to start off with the very basic syntax, and build up some more complex\nclasses.\n\nTo create a class, we use the `class` keyword, and give our new class a name. This\nintroduces a new scope in Python, the scope of the class.\n\nTypically, the first thing we shall see in the class is the `__init__` function.\n\n```python\n    class <name_of_class>:\n        def __init__(self, args*):\n            <body>\n```\n\n\n\n## Init method\n\nThe `__init__` function is a function that gets called automatically as soon as a class\nis made. This init function can take many arguments, but must always start with a\n`self`.\n\nIn this example, we are creating a class that represents an x, y coordinate. We've\ncalled this class `Coordinate`, and we've defined our init function to take an x and y\nvalues when the class is being created.\n\n**Note** its more typical to use titlecase when specifying the class name. So when\nreading code its easy to see when you're creating a class versus calling a\nfunction. You should use this style.\n\n```python\n    class Coordinate:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n```\n\n\n\n## Instantiating\n\nTo create an *instance* of this class, call the name of the class as you would a\nfunction, and pass any parameters you've defined in the init function.\n\nIn this example, we are creating a new vector using `Vector(...)` and we're passing the\nx and y coordinate.\n\n```python\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    \n    point_1 = Vector(5, 2)\n```\n\n\n\n## Class variables\n\nIn the previous example, we've been creating a class variables by using\n`self.<variable_name>`. This is telling Python *this class should have a variable of\nthis name*.\n\nIt allows then to reference the variable when working with the class.\n\n```python\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n            self.length = self.x + self.y\n    \n    point_1 = Vector(5, 2)\n    print(point_1.x)\n    print(point_1.y)\n    print(point_1.length)\n```\n\n    Results: \n    # => 5\n    # => 2\n    # => 7\n\n\n\n\n## Class Methods\n\nA class can have many methods associated with it. To create a new method, we create a\nfunction within the scope of the class, remember that the first parameter of the\nfunction should be `self`.\n\nEven in these functions, we can refer to our `self.x` and `self.y` within this new\nfunction.\n\nYou'll notice that to call this function, we using the `.length()` method similar to\nhow we've worked with strings/lists/etc. This is because in Python, everything is an\nobject!\n\n```python\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def length(self):\n            return self.x + self.y\n    \n    \n    my_point = Vector(2, 5)\n    print(my_point.length())\n```\n\n    Results: \n    # => 7\n\n## dunder-methods\n\nWhile we could, for example, create a function called `.print()`, sometimes we would\nlike to use the in built functions like `print()`. When creating a class, there is a\nset of *dunder-methods* (double-under to reference the two '`__`' characters either side\nof the function name).\n\nOne of these dunder-methods is `__repr__`, which allows us to specify how the object\nlooks when its printed.\n\n```python\n    class OldVector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    print(OldVector(2, 5))\n    \n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def __repr__(self):\n            return f\"Vector({self.x}, {self.y})\"\n    \n    print(Vector(2, 5))\n```\n\n    Results: \n    # => <__main__.OldVector object at 0x7f658721e250>\n    # => Vector(2, 5)\n\n\nThere are many more dunder-methods you should know when creating classes. We shall go through:\n\n-   `__len__` &#x2013; specify how the length of the class should be computed.\n-   `__getitem__` &#x2013; how to index over the class\n-   `__call__` &#x2013; how to use the class like a function\n-   `__iter__` &#x2013; what to do when iteration starts\n-   `__next__` &#x2013; what to do at the next step of the iteration\n\n\n## `__len__`\n\nThe `__len__` function allows us to specify how the `len()` function acts on the\nclass. Take this hypothetical dataset. We create a `__len__` function that returns the\nlength of the unique elements in the dataset.\n\n```python\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __len__(self):\n            \"\"\"Return the length of unique elements\"\"\"\n            return len(set(self.data))\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(len(data))\n```\n\n    Results: \n    # => 4\n\n\n\n\n## `__getitem__`\n\nNext `__getitem__` allows us to index over a class. This new function must include `self`\nand a variable to pass the index. Here I've used `idx`. In this function I am simply\nindexing on the on the classes `self.data`.\n\n```python\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __getitem__(self, idx):\n            return self.data[idx]\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(data[2])\n```\n\n    Results: \n    # => 3\n\n\n\n\n## `__call__`\n\nIn a small number of cases, it is nice to use the class just like a function. This is\nwhat `__call__` allows us to do. In this function we specify what should happen when\nclass is 'called' like a function. In this simple example, we are creating a function\nthat prints the type of food being used as a parameter to the function.\n\n```python\n    class Jaguar:\n        def __call__(self, food):\n            print(f\"The jaguar eats the {food}.\")\n    \n    food = \"apple\"\n    animal = Jaguar()\n    \n    animal(food)\n```\n\n    Results: \n    # => The jaguar eats the apple.\n\n## `__iter__` and `__next__`\n\n`__iter__` and `__next__` allow us to make our class iterable, i.e. we can use it in a\n`for` loop for example.\n\nThe `__iter__` function should define what happens when we start the iteration, and\n`__next__` defines what happens at every step of the iteration.\n\nLet's take a look at an example where we have an iterable set of prime numbers.\n\n```python\n    class Primes:\n        def __init__(self):\n            self.primes = [2, 3, 5, 7, 11]\n    \n        def __iter__(self):\n            self.idx = 0\n            return self\n    \n        def __len__(self):\n            return len(self.primes)\n    \n        def __next__(self):\n            if self.idx < len(self):\n                item = self.primes[self.idx]\n                self.idx += 1\n                return item\n            else:\n                raise StopIteration\n```\n\nAnd now we can iterate over this class\n\n```python\n    prime_numbers = Primes()\n    \n    for prime_number in prime_numbers:\n        print(prime_number)\n```\n\n    Results: \n    # => 2\n    # => 3\n    # => 5\n    # => 7\n    # => 11\n\n\n## Inheritance\n\nOne special thing about OOP is that its normally designed to provide inheritance &#x2013;\nthis is true in Python. Inheritance is where you have a base class, and other classes\ninherit from this base class. This means that the class that inherits from the base\nclass has access to the same methods and class variables. In some cases, it can\noverride some of these features.\n\nLet's take a look an example.\n\n```python\n    class Animal:\n        def growl(self):\n            print(\"The animal growls\")\n    \n        def walk(self):\n            raise NotImplementError\n```\n\nHere we have created a simple class called Animal, that has two functions, one of\nwhich will raise an error if its called.\n\nWe can inherit from this Animal class by placing our base class in `()` after the new\nclass name.\n\nHere we are creating two classes, Tiger and Duck. Both of these new classes inherit\nfrom Animal. Also, both of these classes are overriding the walk functions. But they\nare not creating a growl method themselves.\n\n```python\n    class Tiger(Animal):\n        def walk(self):\n            print(\"The Tiger walks through the jungle\")\n    \n    class Duck(Animal):\n        def walk(self):\n            print(\"The Duck walks through the jungle\")\n```\n\nLook at what happens when we create instances of these classes, and call the\nfunctions. First we see that the correct method has been called. I.e. for the duck\nclass, the correct `walk` method was called.\n\n```python\n    first_animal = Tiger()\n    second_animal = Duck()\n    \n    first_animal.walk()\n    second_animal.walk()\n```\n\n    Results: \n    # => The Tiger walks through the jungle\n    # => The Duck walks through the jungle\n\nBut what happens if we call the `.growl()` method?\n\n```python\n    first_animal.growl()\n    second_animal.growl()\n```\n\n    Results: \n    # => The animal growls\n    # => The animal growls\n\nWe see that it still works. Even though both Duck and Tiger didn't create a `.growl()`\nmethod, it inherited it from the base class Animal. This works for class methods and\nclass variables.\n\n\n\n\n# Exercise - An object based library system\n\nWe're going to improve on our library system from last lecture. Instead of a\n`functional` style of code, we're going to use a OOP paradigm to create our solution.\n\nLike last time, we're going to create our solution one step at a time.\n\nFirst, we need to create our class called `Database`. This database is going to take an\noptional parameter in its init function &#x2013; the data. If the user specifies data\n(represented as a list of dictionaries like last time), then the class will populate\na class variable called data, else this class variable will be set to an empty list.\n\nSummary:\n\n-   Create a class called `Database`.\n-   When creating an instance of `Database`, the user can optionally specify a list of\n    dictionaries to initialise the class variable `data` with. If no data is provided,\n    this class variable will be initialised to an empty list.\n\n\n## Adding data\n\nWe will want to include a function to add data to our database.\n\nCreate a class method called `add`, that takes three arguments (in addition to `self` of\ncourse), the title, the author, and the release date.\n\nThis add function adds the new book entry to the end of `data`. Populate this database\nwith the following information.\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n\n<col  class=\"org-right\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">Title</th>\n<th scope=\"col\" class=\"org-left\">Author</th>\n<th scope=\"col\" class=\"org-right\">Release Date</th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td class=\"org-left\">Moby Dick</td>\n<td class=\"org-left\">Herman Melville</td>\n<td class=\"org-right\">1851</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">A Study in Scarlet</td>\n<td class=\"org-left\">Sir Arthur Conan Doyle</td>\n<td class=\"org-right\">1887</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Frankenstein</td>\n<td class=\"org-left\">Mary Shelley</td>\n<td class=\"org-right\">1818</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Hitchhikers Guide to the Galaxy</td>\n<td class=\"org-left\">Douglas Adams</td>\n<td class=\"org-right\">1879</td>\n</tr>\n</tbody>\n</table>\n\n\n\n\n## Locating a book\n\nCreate a class method called locate by title that takes the title of the book to look\nup, and returns the dictionary of all books that have this title. Unlike last time,\nwe don't need to pass the `data` as an argument, as its contained within the class.\n\n\n\n\n## Updating our database\n\nCreate a class method called `update` that takes 4 arguments:, 1) the key of the value\nwe want to update 2) the value we want to update it to 3) the key we want to check\nto find out if we have the correct book and 4) the value of the key to check if we\nhave the correct book.\n\n```python\n    db.update(key=\"release_date\", value=1979, where_key=\"title\",\n              where_value=\"Hitchhikers Guide to the Galaxy\")\n```\n\nUse this to fix the release data of the Hitchhiker's book.\n\n\n\n\n## Printed representation\n\nUsing the `__str__` dunder-method (this is similar to `__repr__` as we saw before),\ncreate a function that prints out a formatted representation of the entire database\nas a string. Some of the output should look like:\n\n    Library System\n    --------------\n    \n    Entry 1:\n    - Name: Moby Dick\n    - Author: Herman Melville\n    - Release Date: 1851\n    ...\n\n\n## Extending our OOP usage\n\nSo far we've used a list of dictionaries. One issue with this is that there is no\nconstraints on the keys we can use. This will certainly create problems if certain\nkeys are missing.\n\nInstead of using dictionaries. We can create another class called `Book` that will take\nthree arguments when it is initialised: `name`, `author`, and `release_date`. The init\nfunction should initialise three class variables to save this information.\n\nModify the database to, instead of working with a list of dictionaries, work with a\nlist of Book objects.\n\n\n\n\n## Printed representation &#x2013; challenge.\n\nImprove upon the printed representation of the last exercise but instead of bulleted\nlists, use formatted tables using `f-string` formatting\n(<https://zetcode.com/python/fstring/>).\n\nThe output should look like this:\n\n    Library System\n    --------------\n    \n    | Name           | Author           | Release Data |\n    |----------------|------------------|--------------|\n    | Moby Dick      | Herman Melville  |         1851 |\n    ...\n\nNotice how Release date is right justified, while Name and Author are left justified.\n\n","srcMarkdownNoYaml":"\n\n\n# Dealing with Errors\n\nWhen programming, its good to be defensive and handle errors gracefully. For example,\nif you're creating a program, that as part of its process, reads from a file, its\npossible that this file may not exist at the point the program tries to read it. If\nit doesn't exist, the program will crash giving an error such as: `FileNotfoundError`.\n\nPerhaps this file is non-essential to the operation of the program, and we can\ncontinue without the file. In these cases, we will want to appropriately catch the\nerror to prevent it from stopping Python.\n\n## Try-catch\n\nTry-catches are keywords that introduce a scope where the statements are executed,\nand if an error (of a certain type IndexError in this example) occurs, different\nstatements could be executed.\n\nIn this example, we are trying to access an element in a list using an index larger\nthan the length of the list. This will produce an `IndexError`. Instead of exiting\nPython with an error, however, we can catch the error, and print a string.\n\n```python\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError:\n        print(\"Couldn't access element\")\n```\n\n    Results: \n    # => Couldn't access element\n\n\n## Capturing messages\n\nIf we wanted to include the original error message in the print statement, we can use\nthe form:\n\n```python\n    except <error> as <variable>\n```\n\nThis provides us with an variable containing the original error that we can use later\non in the try-catch form.\n\n```python\n    x = [1, 2, 3]\n    \n    try:\n        print(x[3])\n    except IndexError as e:\n        print(f\"Couldn't access elements at index beacuse: {e}\")\n```\n\n    Results: \n    # => Couldn't access elements at index beacuse: list index out of range\n\n\n## Types of exceptions\n\nThere are numerous types of errors that could occur in a Python. Here are just some\nof the most common.\n\n-   `IndexError` &#x2013; Raised when a sequence subscript is out of range.\n-   `ValueError` &#x2013; Raised when an operation or function receives an argument that has the right type but an inappropriate value\n-   `AssertionError` &#x2013; Raised when an assert statement fails.\n-   `FileNotFoundError` &#x2013; Raised when a file or directory is requested but doesnâ€™t exist.\n\nThe full list of exceptions in Python 3 can be found at: <https://docs.python.org/3/library/exceptions.html>\n\n\n## Assertions\n\nOne of the previous errors (`AssertionError`) occurs when an assert statement\nfails. Assert is a keyword provided to test some condition and raise an error if the\ncondition is false. It typically requires less code than an `if`-statement that raises\nan error, so they might be useful for checking the inputs to functions, for example:\n\n```python\n    def my_divide(a, b):\n        assert b != 0\n        return a / b\n    \n    my_divide(1, 2)\n    my_divide(1, 0)\n```\n\nHere we are checking that the divisor is not a 0, in which case division is not defined.\n\n\n# OOP\n\n\n## Introduction to classes\n\nA class is some representation (can be abstract) of an object. Classes can be used to\ncreate some kind of structure that can be manipulated and changed, just like the ways\nyou've seen with lists, dictionaries, etc.\n\nClasses allow us to perform Object-oriented Programming (OOP), where we represent\nconcepts by classes.\n\nBut to properly understand how classes work, and why we would want to use them, we\nshould take a look at some examples.\n\n\n## Basic syntax\n\nWe're going to start off with the very basic syntax, and build up some more complex\nclasses.\n\nTo create a class, we use the `class` keyword, and give our new class a name. This\nintroduces a new scope in Python, the scope of the class.\n\nTypically, the first thing we shall see in the class is the `__init__` function.\n\n```python\n    class <name_of_class>:\n        def __init__(self, args*):\n            <body>\n```\n\n\n\n## Init method\n\nThe `__init__` function is a function that gets called automatically as soon as a class\nis made. This init function can take many arguments, but must always start with a\n`self`.\n\nIn this example, we are creating a class that represents an x, y coordinate. We've\ncalled this class `Coordinate`, and we've defined our init function to take an x and y\nvalues when the class is being created.\n\n**Note** its more typical to use titlecase when specifying the class name. So when\nreading code its easy to see when you're creating a class versus calling a\nfunction. You should use this style.\n\n```python\n    class Coordinate:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n```\n\n\n\n## Instantiating\n\nTo create an *instance* of this class, call the name of the class as you would a\nfunction, and pass any parameters you've defined in the init function.\n\nIn this example, we are creating a new vector using `Vector(...)` and we're passing the\nx and y coordinate.\n\n```python\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    \n    point_1 = Vector(5, 2)\n```\n\n\n\n## Class variables\n\nIn the previous example, we've been creating a class variables by using\n`self.<variable_name>`. This is telling Python *this class should have a variable of\nthis name*.\n\nIt allows then to reference the variable when working with the class.\n\n```python\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n            self.length = self.x + self.y\n    \n    point_1 = Vector(5, 2)\n    print(point_1.x)\n    print(point_1.y)\n    print(point_1.length)\n```\n\n    Results: \n    # => 5\n    # => 2\n    # => 7\n\n\n\n\n## Class Methods\n\nA class can have many methods associated with it. To create a new method, we create a\nfunction within the scope of the class, remember that the first parameter of the\nfunction should be `self`.\n\nEven in these functions, we can refer to our `self.x` and `self.y` within this new\nfunction.\n\nYou'll notice that to call this function, we using the `.length()` method similar to\nhow we've worked with strings/lists/etc. This is because in Python, everything is an\nobject!\n\n```python\n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def length(self):\n            return self.x + self.y\n    \n    \n    my_point = Vector(2, 5)\n    print(my_point.length())\n```\n\n    Results: \n    # => 7\n\n## dunder-methods\n\nWhile we could, for example, create a function called `.print()`, sometimes we would\nlike to use the in built functions like `print()`. When creating a class, there is a\nset of *dunder-methods* (double-under to reference the two '`__`' characters either side\nof the function name).\n\nOne of these dunder-methods is `__repr__`, which allows us to specify how the object\nlooks when its printed.\n\n```python\n    class OldVector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n    print(OldVector(2, 5))\n    \n    class Vector:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n    \n        def __repr__(self):\n            return f\"Vector({self.x}, {self.y})\"\n    \n    print(Vector(2, 5))\n```\n\n    Results: \n    # => <__main__.OldVector object at 0x7f658721e250>\n    # => Vector(2, 5)\n\n\nThere are many more dunder-methods you should know when creating classes. We shall go through:\n\n-   `__len__` &#x2013; specify how the length of the class should be computed.\n-   `__getitem__` &#x2013; how to index over the class\n-   `__call__` &#x2013; how to use the class like a function\n-   `__iter__` &#x2013; what to do when iteration starts\n-   `__next__` &#x2013; what to do at the next step of the iteration\n\n\n## `__len__`\n\nThe `__len__` function allows us to specify how the `len()` function acts on the\nclass. Take this hypothetical dataset. We create a `__len__` function that returns the\nlength of the unique elements in the dataset.\n\n```python\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __len__(self):\n            \"\"\"Return the length of unique elements\"\"\"\n            return len(set(self.data))\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(len(data))\n```\n\n    Results: \n    # => 4\n\n\n\n\n## `__getitem__`\n\nNext `__getitem__` allows us to index over a class. This new function must include `self`\nand a variable to pass the index. Here I've used `idx`. In this function I am simply\nindexing on the on the classes `self.data`.\n\n```python\n    class Dataset:\n        def __init__(self, data):\n            self.data = data\n    \n        def __getitem__(self, idx):\n            return self.data[idx]\n    \n    data = Dataset([1, 2, 3, 3, 3, 5, 1])\n    print(data[2])\n```\n\n    Results: \n    # => 3\n\n\n\n\n## `__call__`\n\nIn a small number of cases, it is nice to use the class just like a function. This is\nwhat `__call__` allows us to do. In this function we specify what should happen when\nclass is 'called' like a function. In this simple example, we are creating a function\nthat prints the type of food being used as a parameter to the function.\n\n```python\n    class Jaguar:\n        def __call__(self, food):\n            print(f\"The jaguar eats the {food}.\")\n    \n    food = \"apple\"\n    animal = Jaguar()\n    \n    animal(food)\n```\n\n    Results: \n    # => The jaguar eats the apple.\n\n## `__iter__` and `__next__`\n\n`__iter__` and `__next__` allow us to make our class iterable, i.e. we can use it in a\n`for` loop for example.\n\nThe `__iter__` function should define what happens when we start the iteration, and\n`__next__` defines what happens at every step of the iteration.\n\nLet's take a look at an example where we have an iterable set of prime numbers.\n\n```python\n    class Primes:\n        def __init__(self):\n            self.primes = [2, 3, 5, 7, 11]\n    \n        def __iter__(self):\n            self.idx = 0\n            return self\n    \n        def __len__(self):\n            return len(self.primes)\n    \n        def __next__(self):\n            if self.idx < len(self):\n                item = self.primes[self.idx]\n                self.idx += 1\n                return item\n            else:\n                raise StopIteration\n```\n\nAnd now we can iterate over this class\n\n```python\n    prime_numbers = Primes()\n    \n    for prime_number in prime_numbers:\n        print(prime_number)\n```\n\n    Results: \n    # => 2\n    # => 3\n    # => 5\n    # => 7\n    # => 11\n\n\n## Inheritance\n\nOne special thing about OOP is that its normally designed to provide inheritance &#x2013;\nthis is true in Python. Inheritance is where you have a base class, and other classes\ninherit from this base class. This means that the class that inherits from the base\nclass has access to the same methods and class variables. In some cases, it can\noverride some of these features.\n\nLet's take a look an example.\n\n```python\n    class Animal:\n        def growl(self):\n            print(\"The animal growls\")\n    \n        def walk(self):\n            raise NotImplementError\n```\n\nHere we have created a simple class called Animal, that has two functions, one of\nwhich will raise an error if its called.\n\nWe can inherit from this Animal class by placing our base class in `()` after the new\nclass name.\n\nHere we are creating two classes, Tiger and Duck. Both of these new classes inherit\nfrom Animal. Also, both of these classes are overriding the walk functions. But they\nare not creating a growl method themselves.\n\n```python\n    class Tiger(Animal):\n        def walk(self):\n            print(\"The Tiger walks through the jungle\")\n    \n    class Duck(Animal):\n        def walk(self):\n            print(\"The Duck walks through the jungle\")\n```\n\nLook at what happens when we create instances of these classes, and call the\nfunctions. First we see that the correct method has been called. I.e. for the duck\nclass, the correct `walk` method was called.\n\n```python\n    first_animal = Tiger()\n    second_animal = Duck()\n    \n    first_animal.walk()\n    second_animal.walk()\n```\n\n    Results: \n    # => The Tiger walks through the jungle\n    # => The Duck walks through the jungle\n\nBut what happens if we call the `.growl()` method?\n\n```python\n    first_animal.growl()\n    second_animal.growl()\n```\n\n    Results: \n    # => The animal growls\n    # => The animal growls\n\nWe see that it still works. Even though both Duck and Tiger didn't create a `.growl()`\nmethod, it inherited it from the base class Animal. This works for class methods and\nclass variables.\n\n\n\n\n# Exercise - An object based library system\n\nWe're going to improve on our library system from last lecture. Instead of a\n`functional` style of code, we're going to use a OOP paradigm to create our solution.\n\nLike last time, we're going to create our solution one step at a time.\n\nFirst, we need to create our class called `Database`. This database is going to take an\noptional parameter in its init function &#x2013; the data. If the user specifies data\n(represented as a list of dictionaries like last time), then the class will populate\na class variable called data, else this class variable will be set to an empty list.\n\nSummary:\n\n-   Create a class called `Database`.\n-   When creating an instance of `Database`, the user can optionally specify a list of\n    dictionaries to initialise the class variable `data` with. If no data is provided,\n    this class variable will be initialised to an empty list.\n\n\n## Adding data\n\nWe will want to include a function to add data to our database.\n\nCreate a class method called `add`, that takes three arguments (in addition to `self` of\ncourse), the title, the author, and the release date.\n\nThis add function adds the new book entry to the end of `data`. Populate this database\nwith the following information.\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n\n<col  class=\"org-right\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">Title</th>\n<th scope=\"col\" class=\"org-left\">Author</th>\n<th scope=\"col\" class=\"org-right\">Release Date</th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td class=\"org-left\">Moby Dick</td>\n<td class=\"org-left\">Herman Melville</td>\n<td class=\"org-right\">1851</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">A Study in Scarlet</td>\n<td class=\"org-left\">Sir Arthur Conan Doyle</td>\n<td class=\"org-right\">1887</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Frankenstein</td>\n<td class=\"org-left\">Mary Shelley</td>\n<td class=\"org-right\">1818</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Hitchhikers Guide to the Galaxy</td>\n<td class=\"org-left\">Douglas Adams</td>\n<td class=\"org-right\">1879</td>\n</tr>\n</tbody>\n</table>\n\n\n\n\n## Locating a book\n\nCreate a class method called locate by title that takes the title of the book to look\nup, and returns the dictionary of all books that have this title. Unlike last time,\nwe don't need to pass the `data` as an argument, as its contained within the class.\n\n\n\n\n## Updating our database\n\nCreate a class method called `update` that takes 4 arguments:, 1) the key of the value\nwe want to update 2) the value we want to update it to 3) the key we want to check\nto find out if we have the correct book and 4) the value of the key to check if we\nhave the correct book.\n\n```python\n    db.update(key=\"release_date\", value=1979, where_key=\"title\",\n              where_value=\"Hitchhikers Guide to the Galaxy\")\n```\n\nUse this to fix the release data of the Hitchhiker's book.\n\n\n\n\n## Printed representation\n\nUsing the `__str__` dunder-method (this is similar to `__repr__` as we saw before),\ncreate a function that prints out a formatted representation of the entire database\nas a string. Some of the output should look like:\n\n    Library System\n    --------------\n    \n    Entry 1:\n    - Name: Moby Dick\n    - Author: Herman Melville\n    - Release Date: 1851\n    ...\n\n\n## Extending our OOP usage\n\nSo far we've used a list of dictionaries. One issue with this is that there is no\nconstraints on the keys we can use. This will certainly create problems if certain\nkeys are missing.\n\nInstead of using dictionaries. We can create another class called `Book` that will take\nthree arguments when it is initialised: `name`, `author`, and `release_date`. The init\nfunction should initialise three class variables to save this information.\n\nModify the database to, instead of working with a list of dictionaries, work with a\nlist of Book objects.\n\n\n\n\n## Printed representation &#x2013; challenge.\n\nImprove upon the printed representation of the last exercise but instead of bulleted\nlists, use formatted tables using `f-string` formatting\n(<https://zetcode.com/python/fstring/>).\n\nThe output should look like this:\n\n    Library System\n    --------------\n    \n    | Name           | Author           | Release Data |\n    |----------------|------------------|--------------|\n    | Moby Dick      | Herman Melville  |         1851 |\n    ...\n\nNotice how Release date is right justified, while Name and Author are left justified.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"lecture-2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":["yeti","style.scss"],"smooth-scroll":true,"title":"Errors & Object Oriented Programming","subtitle":"Lecture 2","author":"Jay Paul Morgan"},"extensions":{"book":{"multiFile":true}}},"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"lecture-2-reveal.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.3.450","auto-stretch":true,"theme":"serif","title":"Errors & Object Oriented Programming","subtitle":"Lecture 2","author":"Jay Paul Morgan","scrollable":true,"smaller":false,"slideNumber":true,"navigationMode":"default","transition":"slide"}}},"projectFormats":["html","revealjs"]}