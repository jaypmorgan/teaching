{"title":"Python Introduction","markdown":{"yaml":{"title":"Python Introduction","subtitle":"Lecture 1","author":"Jay Paul Morgan","format":{"html":"default","revealjs":{"output-file":"lecture-1-reveal.html","scrollable":true,"smaller":false,"slide-number":true,"slide-level":2,"navigation-mode":"vertical","transition":"slide"}}},"headingText":"Python","containsRefs":false,"markdown":"\n\n![](./images/python-objects.png)\n\n\n-   Python is a *high-level* programming language created in 1991.\n-   While it is an old language, its become vastly popular thanks to its use in data\n    science and other mathematics-based disciplines. While also being able to perform\n    tasks such as GUI, web-development and much more.\n-   Because the language is high-level and *interpreted*, programmers can often find\n    themselves more productive in Python than in other languages such as say C++.\n\n\n## A first program\n\nWe're going to start with the 'Hello, World' program that prints `Hello, World!` to the\nscreen. In python this is as simple as writing:\n\n```python\n    print(\"Hello, World!\")   # this prints: Hello, World!\n```\n\n    Results: \n    # => Hello, World!\n\n**NOTE** anything following a `#` is a comment and is completely ignored by the\ncomputer. It is there for you to document your code for others, and most\nimportantly, for yourself.\n\n## Running this program\n\nBefore we can run this program, we need to save it somewhere. For this, will\ncreate a new file, insert this text, and save it as `<filename>.py`, where\n`<filename>` is what we want to call the script. This name doesn't matter for its\nexecution.\n\nOnce we have created the *script*, we can run it from the *command line*. We will\nget into the command line in a later lecture, but right now all you need to know\nis:\n\n```bash\n    python3 <filename>.py\n```\n\n## An alternative method of running python\n\nYou may notice that if you don't give `python` a filename to run, you will enter\nsomething called the `REPL`.\n\n```\n    Python 3.9.5 (default, Jun  4 2021, 12:28:51) \n    [GCC 7.5.0] :: Anaconda, Inc. on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> \n```\n\n`REPL` stands for `READ`, `EXECUTE`, `PRINT`, `LOOP`.\n\n## Variables\n\nA *variable* is a *symbol* associated with a *value*. This value can differ widely, and we\nwill take a look at different types of values/data later.\n\nNeverthless, variables are useful for *referring* to values and *storing* to the results\nof a computation.\n\n```python\n    x = 1\n    y = 2\n    z = x + y\n    print(z)   # prints: 3\n    \n    # variables can be /overwritten/\n    z = \"hello, world\"\n    print(z)   # prints: hello, world\n```\n\n    Results: \n    # => 3\n    # => hello, world\n\n\n\n\n# Types of data\n\n\n## Primitive data types\n\nPrimitive data types are the most fundamental parts of programming, they cannot\nbe *broken* down.\n\n```python\n    \"Hello\" # string\n    1       # integer\n    1.0     # float\n    True    # Boolean (or bool for short)\n```\n\nWe can get the type of some data by using the `type(...)` function. For example,\n\n```python\n    print(type(5))\n    print(type(5.0))\n    \n    x = \"all cats meow\"\n    \n    print(type(x))\n```\n\n    Results: \n    # => <class 'int'>\n    # => <class 'float'>\n    # => <class 'str'>\n\n## Basic Math with primitives\n\nUsing these primitive data types, we can do some basic math operations!\n\n```python\n    print(1 + 2)    # Addtion\n    print(1 - 2)    # Subtraction\n    print(1 * 2)    # Multiplication\n    print(1 / 2)    # Division\n    print(2 ** 2)   # Exponent\n    print(3 % 2)    # Modulo operator\n```\n\n    Results: \n    # => 3\n    # => -1\n    # => 2\n    # => 0.5\n    # => 4\n    # => 1\n\nSometimes types get converted to the same type:\n\n```python\n    print(1.0 + 2)  # float + integer = float\n```\n\n    Results: \n    # => 3.0\n\nEven more interesting is with Booleans!\n\n```python\n    True + True\n```\n\n    Results: \n    # => 2\n\n## BODMAS in Python\n\nLike in mathematics, certain math operator take precedence over others.\n\n-   B - Brackets\n-   O - Orders (roots, exponents)\n-   D - division\n-   M - multiplication\n-   A - addition\n-   S - subtraction.\n\nTo make the context clear as to what operations to perform first, use brackets.\n\n```python\n    (5 / 5) + 1\n    5 / (5 + 1)\n```\n\n    Results: \n    # => 2.0\n    # => 0.8333333333333334\n\n## Basic Math &#x2013; Quick exercise\n\nWrite the following equation in python:\n\n$(5 + 2) \\times (\\frac{10}{2} + 10)^2$\n\n**Remember** to use parentheses `( )` to ensure that operations take precedence over\nothers.\n\nYour answer should come out as: `1575.0`\n\n# Working with Strings\n\n## Formatting strings\n\nIn many previous examples when we've printed strings, we've done something like:\n\n```python\n    age = 35\n    \n    print(\"The value of age is\", age)\n```\n\n    Results: \n    # => The value of age is 35\n\nWhile this works in this small context, it can get pretty cumbersome if we have many\nvariables we want to print, and we also want to change how they are displayed when\nthey are printed.\n\nWe're going to take a look now at much better ways of printing.\n\n\n## Better ways of printing strings - %\n\nThe first method is using `%`. When we print, we first construct a string with special\ndelimiters, such as `%s` that denotes a string, and `%d` that denotes a number. This is\ntelling Python where we want the values to be placed in the string.\n\nOnce we've created the string, we need to specify the data, which we do with `%\n(...)`. Like, for example:\n\n```python\n    age = 35\n    name = \"John\"\n    \n    print(\"%d years old\" % age)  # no tuple for one variable\n    print(\"%s is %d years old\" % (name, age)) \n```\n\n    Results: \n    # => 35 years old\n    # => John is 35 years old\n\nHere we are specifying the a string `%s` and number `%d`, and then giving the variables\nthat correspond with that data type.\n\nThe special delimiters correspond with a data type. Here are some of the most common:\n\n-   `%s` &#x2013; For strings\n-   `%d` &#x2013; For numbers\n-   `%f` &#x2013; For floating point numbers.\n\nThere are others such as `%x` that prints the hexadecimal representation, but these are\nless common. You can find the full list at: <https://docs.python.org/3/library/stdtypes.html#old-string-formatting>\n\nWhen using these delimiters, we can add modifiers to how they format and display the\nvalue. Take a very common example, where we have a floating point value, and, when\nprinting it, we only want to print to 3 decimal places. To accomplish this, we again\nuse `%f` but add a `.3` to between the `%` and `f`. In this example, we are printing &pi; to 3\ndecimal places.\n\n```python\n    print(\"Pi to 3 digits is: %.3f\" % 3.1415926535)\n```\n\n    Results: \n    # => Pi to 3 digits is: 3.142\n\nIn the previous example, we used `.3` to specify 3 decimal places. If we put a number\nbefore the decimal, like `10.3` we are telling Python *make this float occupy 10 spaces\nand this float should have 3 decimal places printed*.  When it gets printed, you will\nnotice that it shifts to the right, it gets padded by space. If we use a negative\nnumber in front of the decimal place, we are telling python to shift it to the left.\n\n```python\n    print(\"Pi to 3 digits is: %10.3f\" % 3.1415926535)\n    print(\"Pi to 3 digits is: %-10.3f\" % 3.1415926535)\n```\n\n    Results: \n    # => Pi to 3 digits is:      3.142\n    # => Pi to 3 digits is: 3.142\n\n\nThe final method of formatting strings is a newcomer within the language, it is the\nso-called `f-string`. Where a `f` character is prefixed to the beginning of the string\nyou're creating. `f-string`'s allow you to use Python syntax within the string (again\ndelimited by `{}`.\n\nTake this for example where we are referencing the variables `name` and `age` directly.\n\n```python\n    name = \"Jane\"\n    age = 35\n\n    print(f\"{name} is {age} years old\")\n```\n\n    Results: \n    # => Jane is 35 years old\n\n`f-string`'s allow you to execute Python code within the string. Here we are accessing\nthe value from the dictionary by specifying the key within the string itself! It\ncertainly makes it a lot easier, especially if we only need to access the values for\nthe string itself.\n\n```python\n    contact_info = {\"name\": \"Jane\", \"age\": 35}\n    \n    print(f\"{contact_info['name']} is {contact_info['age']} years old\")\n```\n\n    Results: \n    # => Jane is 35 years old\n\n<https://pyformat.info/>\n\nWe can still format the values when using `f-string`. The method is similar to those\nusing the `%f` specifiers.\n\n```python\n    pi = 3.1415926535\n    print(f\"Pi is {pi:.3f} to 3 decimal places\")\n```\n\n    Results: \n    # => Pi is 3.142 to 3 decimal places\n\nMany more examples can be found at: <https://zetcode.com/python/fstring/>\n\n## Splitting strings\n\nApart from formatting, there are plenty more operations we can perform on strings. We\nare going to highlight some of the most common here.\n\nThe first we're going to look at is splitting a string by a delimiter character using\nthe `.split()` method. If we don't pass any argument to the `.split()` method, then by\ndefault, it will split by spaces. However, we can change this by specifying the\ndelimiter.\n\n```python\n    my_string = \"This is a sentence, where each word is separated by a space\"\n    \n    print(my_string.split())\n    print(my_string.split(\",\"))\n```\n\n    Results: \n    # => ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n    # => ['This is a sentence', ' where each word is separated by a space']\n\n## Joining strings together\n\nAs `.split()` splits a single string into a list, `.join()` joins a list of strings into\na single string. To use `.join()`, we first create a string of the delimiter we want to\nuse to join the list of strings by. In this example we're going to use `\"-\"`. Then we\ncall the `.join()` method, passing the list as an argument.\n\nThe result is a single string using the delimiter to separate the items of the list.\n\n```python\n    x = ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n    \n    print(\"-\".join(x))\n```\n\n    Results: \n    # => This-is-a-sentence,-where-each-word-is-separated-by-a-space\n\n## Changing cases\n\nOther common operations on strings involve change the case. For example:\n\n-   Make the entire string uppercase or lowercase\n-   Making the string title case (every where starts with a capital letter).\n-   Stripping the string by removing any empty spaces either side of the string.\n\n**Note** we can chain many methods together by doing `.method_1().method_2()`, but only if they\nreturn string. If they return `None`, then chaining will not work.\n\n```python\n    x = \"    this String Can change case\"\n    \n    print(x.upper())\n    print(x.lower())\n    print(x.title())\n    print(x.strip())\n    print(x.strip().title())\n```\n\n    Results: \n    # =>     THIS STRING CAN CHANGE CASE\n    # =>     this string can change case\n    # =>     This String Can Change Case\n    # => this String Can change case\n    # => This String Can Change Case\n\n\n## Replacing parts of a string\n\nTo replace a substring, we use the `.replace()` method. The first argument is the old\nstring you want to replace. The second argument is what you want to replace it with.\n\n```python\n    x = \"This is a string that contains some text\"\n    \n    print(x.replace(\"contains some\", \"definitely contains some\"))\n```\n    Results: \n    # => This is a string that definitely contains some text\n\n# Compound data structures\n\n## Container data types/Data structures\n\nContainer data types or data structures, as the name suggests, are used to contain\nother things. Types of containers are:\n\n-   Lists\n-   Dictionaries\n-   Tuples\n-   Sets\n\n```python\n    [1, \"hello\", 2]                 # list\n    {\"my-key\": 2, \"your-key\": 1}    # dictionary (or dict)\n    (1, 2)                          # tuple\n    set(1, 2)                       # set\n```\n\nWe'll take a look at each of these different container types and explore why we\nmight want to use each of them.\n\n\n\n\n## An aside on Terminology\n\nTo make our explanations clearer and reduce confusion, each of the different symbols\nhave unique names.\n\nI will use this terminology consistently throughout the course, and it is common to\nsee the same use outside the course.\n\n-   `[ ]` brackets (square brackets).\n-   `{ }` braces (curly braces).\n-   `( )` parentheses.\n\n\n## Lists\n\nA hetreogenious container. This means that it can store any type of data.\n\n```python\n    x = [1, \"hello\", 2]\n```\n\nElements can be accessed using indexing `[ ]` notation. For example:\n\n```python\n    print(x[0])    # this will get the first element (i.e. 1)\n    print(x[1])    # the second element (i.e. \"hello\")\n    print(x[2])    # the third element (i.e. 2)\n```\n\n    Results: \n    # => 1\n    # => hello\n    # => 2\n\n**notice how the first element is the 0-th item in the list/** we say that python is\n0-indexed.\n\n\n\n\n## Slices\n\nIf we wanted to access an element from a data structure, such as a list, we would use\nthe `[ ]` accessor, specifying the index of the element we wish to retrieve (remember\nthat indexes start at zero!). But what if we ranted to access many elements at once?\nWell to accomplish that, we have a slice or a range of indexes (not to be confused\nwith the `range` function). A slice is defined as:\n\n    start_index:end_index\n\nwhere the `end_index` is non inclusive &#x2013; it doesn't get included in the result. Here\nis an example where we have a list of 6 numbers from 0 to 5, and we slice the list from index\n0 to 3. Notice how the 3rd index is not included.\n\n```python\n    x = [0, 1, 2, 3, 4, 5]\n    print(x[0:3])\n```\n\n    Results: \n    # => [0, 1, 2]\n\n\n\n\n## Ranges\n\nWhen we use `start_index:end_index`, the slice increments by 1 from `start_index` to\n`end_index`. If we wanted to increment by a different amount we can use the slicing\nform:\n\n    start_index:end_index:step\n\nHere is an example where we step the indexes by 2:\n\n```python\n    x = list(range(100))\n    print(x[10:15:2])\n```\n\n    Results: \n    # => [10, 12, 14]\n\n\n\n\n## Reverse\n\nOne strange fact about the step is that if we specify a negative number for the step,\nPython will work backwards, and effectively reverse the list.\n\n```python\n    x = list(range(5))\n    \n    print(x[::-1])\n```\n\n    Results: \n    # => [4, 3, 2, 1, 0]\n\n\nIn a previous example, I created a slice like `0:3`. This was a little wasteful as we\ncan write slightly less code. If we write `:end_index`, Python assumes and creates a\nslice from the first index (0) to the `end_index`. If we write `start_index:`, Python\nassumes and creates a slice from `start_index` to the end of the list.\n\n```python\n    x = list(range(100))\n    \n    print(x[:10])\n    print(x[90:])\n```\n\n    Results: \n    # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # => [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n\n## Indexing backwards\n\nFinally, we also work backwards from the end of list. If we use a negative number,\nsuch as -1, we are telling Python, take the elements from the end of the list. -1 is\nthe final index, and numbers lower than -1 work further backwards through the list.\n\n```python\n    x = list(range(100))\n    \n    print(x[-1])\n    print(x[-2])\n```\n\n    Results: \n    # => 99\n    # => 98\n\nSlicing with negative indexes, also works. Here we are creating a slice from the end\nof the list - 10, to the last (but not including) index.\n\n```python\n    x = list(range(100))\n    \n    print(x[-10:-1])\n```\n\n    Results: \n    # => [90, 91, 92, 93, 94, 95, 96, 97, 98]\n\n\n## Adding data to a list\n\nIf we want to add items to the end of the list, we use the `append` function:\n\n```python\n    my_list = []\n    \n    my_list.append(\"all\")\n    my_list.append(\"dogs\")\n    my_list.append(\"bark\")\n    \n    print(my_list)\n```\n\n    Results: \n    # => ['all', 'dogs', 'bark']\n\n\n## Dictionaries\n\nDictionaries are a little different from lists as each 'element' consists of a\nkey-pair value. Let's have a look at some examples where the dictionaries contains\n**one** element:\n\n```python\n    my_dictionary = {\"key\": \"value\"}\n    my_other_dict = {\"age\": 25}\n```\n\nTo access the *value*, we get it using `[key]` notation:\n\n```python\n    my_other_dict[\"age\"]\n```\n\n    Results: \n    # => 25\n\n**NOTE** keys are unique, i.e:\n\n```python\n    my_dictionary = {\"age\": 25, \"age\": 15}\n    my_dictionary[\"age\"]\n```\n\n    Results: \n    # => 15\n\nThe key in the dictionary doesn't necessarily need to be a string. For example, in\nthis case, we have created two key-pair elements, where the keys to both are tuples\nof numbers.\n\n```python\n    my_dictionary = {(1, 2): \"square\", (3, 4): \"circle\"}\n    \n    print(my_dictionary[(1, 2)])\n```\n\n    Results: \n    # => square\n\n### adding data\n\nIf we want to add data to a dictionary, we simply perform the accessor method with a\nkey that is not in the dictionary:\n\n```python\n    my_dict = {}\n    \n    my_dict[\"name\"] = \"James\"\n    my_dict[\"age\"] = 35\n    \n    print(my_dict)\n```\n\n    Results: \n    # => {'name': 'James', 'age': 35}\n\n\n\n\n### Quick Exercise\n\n-   Create a dictionary for the following address, and assign it a variable name\n    called `address`:\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">Key</th>\n<th scope=\"col\" class=\"org-left\">Value</th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td class=\"org-left\">number</td>\n<td class=\"org-left\">22</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">street</td>\n<td class=\"org-left\">Bakers Street</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">city</td>\n<td class=\"org-left\">London</td>\n</tr>\n</tbody>\n</table>\n\n-   Print out the address's street name using the `[ ]` accessor with the correct key.\n\n\n\n\n## Tuples\n\n```python\n    my_tuple = (1, 56, -2)\n```\n\nLike lists, elements of the tuple can be accessed by their position in the list,\nstarting with the 0-th element:\n\n```python\n    print(my_tuple[0])  # => 1\n    print(my_tuple[1])  # => 56\n    print(my_tuple[2])  # => -2\n```\n\n    Results: \n    # => 1\n    # => 56\n    # => -2\n\nUnlike lists, tuples cannot be changed after they've been created. We say they are\n**immutable**. So this will **not** work:\n\n```python\n    my_tuple[2] = \"dogs\"  # creates an Error\n```\n\n    Results: \n    # => Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"/tmp/pyKdIIcx\", line 18, in <module>\n      File \"<string>\", line 1, in <module>\n    TypeError: 'tuple' object does not support item assignment\n\n\n\n\n## Sets\n\nSets in Python are like tuples, but contain only unique elements.\n\nYou can use the `set( )` function (**more on functions later!**), supplying a list, to create a set:\n\n```python\n    my_set = set([1, 2, 2, 2, 3, 4])\n    my_set\n```\n\n    Results: \n    # => {1, 2, 3, 4}\n\nNotice how there is only one '2' in the resulting set, duplicate elements are removed.\n\n\n\n\n### adding data\n\nIf we want to add data to a set, we use the `.add()` method. The element used as an\nargument to this function will only be added to the set if it is not already in the\nset.\n\n```python\n    my_set = set([])\n    \n    my_set.add(1)\n    my_set.add(2)\n    my_set.add(1)\n    \n    print(my_set)\n```\n\n    Results: \n    # => {1, 2}\n\n\n\n\n# Conditional expressions\n\n\n## If statement\n\nIf statements allow for branching paths of execution. In other words, we can execute\nsome statements if some conditions holds (or does not hold).\n\nThe structure of a simple if statement is:\n\n    if <condition>:\n        <body>\n\n```python\n    x = 2\n    y = \"stop\"\n    \n    if x < 5:\n        print(\"X is less than five\")\n    if y == \"go\":\n        print(\"All systems go!!\")\n```\n\n    Results: \n    # => X is less than five\n\nIn the previous example, the first `print` statement was only executed if the `x < 5`\nevaluates to `True`, but in python, we can add another *branch* if the condition\nevaluates to `False`. This branch is denoted by the `else` keyword.\n\n```python\n    x = 10\n    \n    if x < 5:\n        print(\"X is less than five\")\n    else:\n        print(\"X is greater than or equal to five\")\n```\n\n    Results: \n    # => X is greater than or equal to five\n\n\n## does it contain a substring?\n\nWe can check if a string exists within another string using the `in` keyword. This\nreturns a Boolean value, so we can use it as a condition to an `if` statement.\n\n```python\n    x = \"This is a string that contains some text\"\n    \n    if \"text\" in x:\n        print(\"It exists\")\n```\n\n    Results: \n    # => It exists\n\n## If statement &#x2013; Quick Exercise\n\n-   Create a variable called `age` and assign the value of this variable `35`.\n-   Create and `if` statement that prints the square of `age` if the value of `age` is more\n    than 24.\n-   This if statement should have an else condition, that prints `age` divided by 2.\n-   What is the printed value?\n\n\n## Multiple paths\n\nIf we wanted to add multiple potential paths, we can add more using the `elif\n<condition>` keywords.\n\nNote: The conditions are checked from top to bottom, only executing the else if none\nevaluate to `True`. The first condition that evaluates to `True` is executed, the rest\nare skipped.\n\n    x = 15\n    \n    if x < 5:\n        print(\"X is less than five\")\n    elif x > 10:\n        print(\"X is greater than ten\")\n    else:\n        print(\"X is between five and ten\")\n\n    Results: \n    # => X is greater than ten\n\n\n## Inline if-statements\n\nSometimes, we might want to conditionally set a variable a value. For this, we can\nuse an *inline* if statement. The form of an inline if statement is:\n\n`<value-if-true> if <condition> else <value-if-false>`\n\n    x = 10\n    \n    y = 5 if x > 5 else 2\n    \n    print(x + y)\n\n    Results: \n    # => 15\n\n\n## Boolean Logic\n\nAs we've seen, `if` statements are checking for conditions to evaluate to `True` or\n`False`. In python we use various comparison operators to check for conditions that\nevaluate to `Booleans`.\n\n### Comparison operators\n\n-   `<` less than\n-   `<=` less than or equal to\n-   `>` greater than\n-   `>=` greater than or equal to\n-   `==` is equal to\n-   `not` negation\n\nIf we want to check for multiple conditions, we can use conjunctives or disjunctive\noperators to combine the Boolean formulas.\n\nConjunctives/Disjunctives\n\n-   `and` all boolean expressions must evaluate to true\n-   `or` only one expression needs to be true\n\n\n\n\n### Not\n\nUsing `not` you can invert the Boolean result of the expression.\n\n    print(not True)\n\n    Results: \n    # => False\n\n    x = 10\n    \n    if not x == 11:\n        print(\"X is not 11\")\n\n    Results: \n    # => X is not 11\n\n\n\n\n### And\n\nLet's take an example using the `and` keyword. `and` here is checking that `x` is above or\nequal to 10 **and** `y` is exactly 5. If either of the conditions is `False`, python will\nexecute the `else` path (if there is one, of course!).\n\n    x = 10\n    y = 5\n    \n    if x >= 10 and y == 5:\n        z = x + y\n    else:\n        z = x * y\n    \n    print(z)\n\n    Results: \n    # => 15\n\n\n\n\n### Or\n\nHere we see the use of the `or` keyword. If any of the conditions evaluates to `True`\nthen the whole condition evaluates to `True`.\n\n    x = 10\n    y = 5\n    \n    if x < 5 or y == 5:\n        print(\"We got here!\")\n    else:\n        print(\"We got here instead...\")\n\n    Results: \n    # => We got here!\n\nNote: `or` is short-circuiting. This means that if tests the conditions left-to-right,\nand when it finds something that is `True` it stops evaluating the rest of the\nconditions.\n\n    x = 10\n    \n    if x < 20 or print(\"We got to this condition\"):\n        print(\"The value of x is\", x) \n\n    Results: \n    # => The value of x is 10\n\n\n\n\n### Combining And and Or\n\nIf your Boolean logic refers to a single variable, you can combine the logic without\nthe `and` and `or`. But its not always common.\n\nFor example,\n\n    x = 7\n    \n    if x < 10 and x > 4:\n        print(\"X is between 5 and 10\")\n\nCan be the same as:\n\n    x = 7\n    \n    if 5 < x < 10:\n        print(\"X is between 5 and 10\")\n\n    Results: \n    # => X is between 5 and 10\n\n\n\n\n# Iteration\n\n\n\n## For loop\n\nLooping or iteration allows us to perform a series of actions multiple times. We are\ngoing to start with the more useful `for` loop in python. The syntax of a `for` loop is:\n\n    for <variable_name> in <iterable>:\n        <body>\n\n    for i in range(3):\n        print(i)\n\n    Results: \n    # => 0\n    # => 1\n    # => 2\n\n\n\n\n## break\n\nThe previous example loops over the body a fix number of times. But what if we wanted\nto stop looping early? Well, we can use the `break` keyword. This keyword will exit the\nbody of the loop.\n\n    for i in range(10):\n        if i > 5:\n            break\n        print(i)\n\n    Results: \n    # => 0\n    # => 1\n    # => 2\n    # => 3\n    # => 4\n    # => 5\n\n\n\n\n## continue\n\nA different keyword you might want to use is `continue`. Continue allows you to move/skip\nonto the next iteration without executing the entire body of the `for` loop.\n\n    for i in range(10):\n        if i % 2 == 0:\n            continue\n        print(i)\n\n    Results: \n    # => 1\n    # => 3\n    # => 5\n    # => 7\n    # => 9\n\n\n\n\n## ranges\n\nInstead of using `continue` like in the previous slide, the `range` function provides us\nwith some options:\n\n`range(start, stop, step)`\n\nIn this example, we are starting our iteration at 10, ending at 15, but stepping the\ncounter 2 steps.\n\n    for i in range(10, 15, 2):\n        print(i)\n\n    Results: \n    # => 10\n    # => 12\n    # => 14\n\n\n\n\n## Loop over collections\n\nFor loops allow us to iterate over a collection, taking one element at a time. Take\nfor example, a list, and for every item in the list we print its square.\n\n    my_list = [1, 5, 2, 3, 5.5]\n    \n    for el in my_list:\n        print(el**2)\n\n    Results: \n    # => 1\n    # => 25\n    # => 4\n    # => 9\n    # => 30.25\n\n\nThis kind of looping can work for tuples and sets, but as we have seen, dictionaries\nare a little different. Every 'element' in a dictionary consists of a key and a\nvalue. Therefore when we iterate over items in a dictionary, we can assign the key\nand value to different variables in the loop.\n\n**Note** the use of the `.items()` after the dictionary. We will explore this later.\n\n    my_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n    \n    for el_key, el_val in my_dict.items():\n        print(\"Key is:\", el_key, \" value is: \", el_val)\n\n    Results: \n    # => Key is: name  and the value is:  jane\n    # => Key is: age  and the value is:  35\n    # => Key is: location  and the value is:  France\n\nWe could also loop over the keys in the dictionary using the `.keys()` method instead\nof `.items()`.\n\n    my_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n    \n    for the_key in my_dict.keys():\n        print(the_key)\n\n    Results: \n    # => name\n    # => age\n    # => loc\n\nOr, the values using `.values()`.\n\n    my_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n    \n    for the_value in my_dict.values():\n        print(the_value)\n\n    Results: \n    # => jane\n    # => 35\n    # => France\n## List comprehensions\n\nWe have seen previously how `for` loops work. Knowing the syntax of a `for` loop and\nwanting to populate a list with some data, we might be tempted to write:\n\n    x = []\n    for i in range(3):\n        x.append(i)\n    \n    print(x)\n\n    Results: \n    # => [0, 1, 2]\n\nWhile this is perfectly valid Python code, Python itself provides 'List\ncomprehensions' to make this process easier.\n\n    x = [i for i in range(3)]\n\n\nThe syntax of a list comprehensions is:\n\n    [ <variable> for <variable> in <iterable> ]\n\nWe can also perform similar actions with a dictionary\n\n    [ <key>, <value> for <key>, <value> in <dictionary.items()> ]\n\n\n\n\n### using `if`'s\n\nPerhaps we only want to optionally perform an action within the list comprehension?\nPython allows us to do this with the inline `if` statement we've seen in the previous lecture.\n\n    x = [i if i < 5 else -1 for i in range(7)]\n    print(x)\n\n    Results: \n    # => [0, 1, 2, 3, 4, -1, -1]\n\nWe add the inline `<var> if <condition> else <other-var>` before the `for` loop part of\nthe comprehension.\n\nThere is another type of `if` statement in a list comprehension, this occurs when we\ndon't have an `else`.\n\n    x = [i for i in range(7) if i < 3]\n    print(x)\n\n    Results: \n    # => [0, 1, 2]\n\nIn this example, we're only 'adding' to the list if the condition ($i < 3$) is true,\nelse the element is not included in the resulting list.\n\n### multiple `for`'s\n\nIf we like, we can also use nested for loops by simply adding another for loop into\nthe comprehension.\n\n    x = [(i, j) for i in range(2) for j in range(2)]\n    \n    print(x)\n\n    Results: \n    # => [(0, 0), (0, 1), (1, 0), (1, 1)]\n\nIn this example, we're creating a tuple for each element, effectively each\ncombination of 1 and 0.\n\n\n\n\n## List comprehensions with dictionary\n\nPython doesn't restrict us to list comprehensions, but we can do a similar\noperation to create a dictionary.\n\n    x = [2, 5, 6]\n    y = {idx: val for idx, val in enumerate(x)}\n    print(y)\n\n    Results: \n    # => {0: 2, 1: 5, 2: 6}\n\nHere, every item in `x` has been associated with its numerical index as a key thanks to\nthe `enumerate` function that returns both the index and value at iteration in the for loop.\n\n## For loop &#x2013; Quick Exercise\n\n-   Create a list of elements:\n    -   2\n    -   \"NA\"\n    -   24\n    -   5\n\n-   Use a `for` loop to iterate over this list.\n-   In the body of the `for` loop, compute $2x + 1$, where $x$ is the current element of\n    the list.\n-   Store the result of this computation in a new variable $y$, and then print y.\n\n**Note** You cannot compute $2x + 1$ of \"NA\", therefore you will to use an `if` statement\nto skip onto the next iteration if it encounters this. **Hint** try: `type(...) =!=` `str`\n\n## While loop\n\nA `while` loop is another looping concept like `for` but it can loop for an arbitrary\namount of times. A `while` loop looks to see if the condition is `True`, and if it is, it\nwill execute the body.\n\nThe syntax of the while loop is:\n\n    while <condition>:\n        <body>\n\n    i = 0\n    \n    while i < 3:\n        print(i)\n        i = i + 1\n\n    Results: \n    # => 0\n    # => 1\n    # => 2\n\n    x = 0\n    y = 1\n    \nHere is another example:\n\n    while x + y < 10:\n        print(\"X is,\", x, \"and y is\", y)\n        x = x + 1\n        y = y * 2\n    \n    print(\"X ended as\", x, \", while y is\", y)\n\n    Results: \n    # => X is, 0 and y is 1\n    # => X is, 1 and y is 2\n    # => X is, 2 and y is 4\n    # => X ended as 3 , while y is 8\n\n# Functions\n\nFunctions are a re-usable set of instructions that can take some arguments and\npossible return something.\n\nThe basic structure of a function is as follows:\n\n    def <function_name>(args*):\n        <body>\n        (optional) return\n\n-   `args*` are 0 to many comma separated symbols.\n-   `body` is to be indented by 4 spaces.\n\nThis is only the function *definition* however. To make it do something, we must *'call'*\nthe function, and supply the arguments as specified in the definition.\n\n    def say_hello():   # function definition\n        print(\"Hello, World!\")\n    \n    say_hello()  # calling the function\n\nWe've already seen some functions provided by Python.\n\n`print` itself is a function with a single argument: what we want to print.\n\n    print(\"Hello, World!\")\n    # ^         ^\n    # |         |\n    # | user supplied argument\n    # |\n    # function name \n\n`set` is another function that takes a single argument: a collection of data with which\nto make a set:\n\n    set([1, 2, 2, 3, 4])\n\n\n## Example usage of a function\n\nLet's make a function that takes two numbers and adds them together:\n\n    def my_addition(a, b):\n        result = a + b\n        return result\n    \n    x = 2\n    y = 3\n    z = my_addition(2, 3)  # return 5 and stores in z\n    print(z)\n\n    Results: \n    # => 5\n\n\n## Quick exercise\n\n-   Create a function called `my_square`. This function should take one argument (you can\n    call this argument what you like).\n-   The body of the function should compute and return the square of the argument.\n-   Call this function with `5.556`.\n-   Store the result of calling this function, and print it.\n-   What is the result?\n\n## Re-usability with Functions\n\nFunctions are better illustrated through some examples, so let's see some!\n\n    name_1 = \"john\"\n    name_2 = \"mary\"\n    name_3 = \"michael\"\n    \n    print(\"Hello \" + name_1 + \", how are you?\")\n    print(\"Hello \" + name_2 + \", how are you?\")\n    print(\"Hello \" + name_3 + \", how are you?\")\n\nThe above is pretty wasteful. Why? Because we are performing the exact same\noperation multiple times, with only the variable changed.\n\nBy abstracting the actions we want to perform into a function, we can ultimately\nreduce the amount of code we write. *Be a lazy programmer!*\n\n    name_1 = \"john\"\n    name_2 = \"mary\"\n    name_3 = \"michael\"\n    \n    def say_hello(name):\n        print(\"Hello \" + name + \", how are you?\")\n    \n    say_hello(name_1)\n    say_hello(name_2)\n    say_hello(name_3)\n\nIn this example, we've used the function as defined with the `def` pattern to write\nthe `print` statement once. Then, we've called the function with each variable as its\nargument.\n\n## Named parameters\n\nWe've seen in previous examples that, when we create a function, we give each of the\narguments (if there are any) a name.\n\nWhen calling this function, we can specify these same names such as:\n\n    def say_hello(name):\n        print(\"Hello,\", name)\n    \n    say_hello(\"Micheal\")\n    say_hello(name=\"Micheal\")\n\n    Results: \n    # => Hello, Micheal\n    # => Hello, Micheal\n\nBy specifying the name of the parameter we're using with the called function, we can\nchange the order\n\n    def say_greeting(greeting, name):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(name=\"John\", greeting=\"Hi\")\n\n    Results: \n    # => Hi John I hope you're having a good day\n\n## Optional/Default/Positional arguments\n\nWhen we call a function with arguments without naming them, we are supplying them by\n*position*.\n\n    def say_greeting(greeting, name):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(#first position, #section position)\n\nThe first position gets mapped to variable name of `greeting` inside the body of the\n`say_greeting` function, while the second position gets mapped to `name`. \n\nSometimes when creating a function we may want to use default arguments, these are\narguments that are used if the call to the function does not specify what their value\nshould be. For example.\n\n    def say_greeting(name, greeting=\"Hello\"):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(\"John\")\n    say_greeting(\"John\", \"Hi\")  # supply greeting as positional argument\n\n    Results: \n    # => Hello John I hope you're having a good day\n    # => Hi John I hope you're having a good day\n\n**Note** if you supply a default argument in the function definition, all arguments after\nthis default argument must also supply a default argument.\n\nSo, this **won't** work:\n\n    def say_greeting(name=\"Jane\", greeting):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(\"John\", \"Hi\")\n\n\n## Recap on arguments\n\n    # defining the function\n    \n    def say_greeting(name, greeting)  # no default arguments\n    def say_greeting(name, greeting=\"Hello\")  # greeting is a default argument\n    def say_greeting(name=\"Jane\", greeting=\"Hello\")  # both arguments have a default\n    \n    # calling the functions\n    \n    say_greeting(\"John\", \"Hi\")  # both arguments are provided by position\n    say_greeting(name=\"John\", greeting=\"Hi\")  # arguments are supplied by name\n    say_greeting(greeting=\"Hi\", name=\"John\")  # the position of named arguments do not matter\n\n## Function doc-strings\n\nTo make it clear for a human to quickly understand what a function is doing, you can\nadd an optional doc-string. This is a string that is added directly after the initial\ndefinition of the function:\n\n    def my_function(x, y):\n        \"\"\"I am a docstring!!!\"\"\"\n        return x + y\n\nSome common use cases for docstrings are explaining what the parameters are that it\nexpects, and what it returns.\n\nIf your explanation is a little longer than a line, a multiline docstring can be\ncreated as long as you're using `\"\"\"` three quotation marks either side of the string\n\n    def my_function(x, y):\n        \"\"\"\n        This is my realllly long docstring\n        that explains how the function works. But sometimes\n        its best not to explain the obvious\n        \"\"\"\n        return x + y\n\n## Understanding scope\n\nIn this example we have two scopes which can be easily seen by the indentation. The\nfirst is the *global* scope. The second scope is the scope of the function. The scope\nof the function can reference variables in the larger scope. But once the function\nscope exits, we can no longer reference the variables from the function.\n\n    x = 10\n    \n    def compute_addition(y):\n        return x + y\n    \n    print(compute_addition(10))\n    print(x)\n    print(y)  # does not work\n\n    Results: \n    # => 20\n    # => 10\n\nEven though we can reference the global scope variable from the scope of the\nfunction, we can't modify it like this:\n\n    x = 10\n    \n    def compute_addition_2(y):\n        x = x + 5  # error local variable referenced before assignment\n        return x + y\n    \n    print(compute_addition_2(10))\n\nIf we really wanted to reference a variable in a global scope and modify its value,\nwe could use the `global` keyword. Doing this makes the\nfunction output something different every time it is called. This can make it\ndifficult to debug incorrect programs.\n\n    x = 10\n    \n    def compute_addition_2(y):\n        global x\n        x = x + 5\n        return x + y\n    \n    print(compute_addition_2(10))\n    print(x)\n    print(compute_addition_2(10))\n\n    Results: \n    # => 25\n    # => 15\n    # => 30\n\nIn almost all cases, avoid using global variables. Instead pass the variables as\nparameters. This can reduce a source of potential errors and ensure that if a\nfunction is called multiple times, the output can be more consistent and expected.\n\n    x = 10\n    \n    def compute_addition_3(x, y):\n        x = x + 5\n        return x + y\n    \n    print(compute_addition_3(x, 10))\n    print(x)\n    print(compute_addition_3(x, 10))\n\n    Results: \n    # => 25\n    # => 10\n    # => 25\n\n# Exercise\n\n## Library system\n\n\n\n\n## Use what you've learnt!\n\nWe're going to create a library system to help locate and lookup information about\nbooks. For example, we want to know the author of book called 'Moby Dick'.\n\nTo create this system, we are going to do it in stages. First, we will want to create\nour database of books:\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n\n<col  class=\"org-right\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">Title</th>\n<th scope=\"col\" class=\"org-left\">Author</th>\n<th scope=\"col\" class=\"org-right\">Release Date</th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td class=\"org-left\">Moby Dick</td>\n<td class=\"org-left\">Herman Melville</td>\n<td class=\"org-right\">1851</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">A Study in Scarlet</td>\n<td class=\"org-left\">Sir Arthur Conan Doyle</td>\n<td class=\"org-right\">1887</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Frankenstein</td>\n<td class=\"org-left\">Mary Shelley</td>\n<td class=\"org-right\">1818</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Hitchhikers Guide to the Galaxy</td>\n<td class=\"org-left\">Douglas Adams</td>\n<td class=\"org-right\">1879</td>\n</tr>\n</tbody>\n</table>\n\nOur database is going to be a list of dictionaries. Where each dictionary is a row\nfrom this table. For example, one of the dictionaries will have the key \"title\" and a\nvalue \"Moby Dick\".\n\nCreate this database and call it `db`.\n\n\n\n\n## Locating Books\n\n-   Create a function called `locate_by_title` that takes the database to look through,\n    and the title to look up as arguments.\n-   This function should check each dictionary, and if the title is the same as what\n    was searched for, it should return the whole dictionary.\n-   Test this function by calling the `locate_by_title` function with `db` and\n    `\"Frankenstein\"`. You should get `{\"title\": \"Frankenstein\", \"author\": ...}`.\n\n**Note** you should include docstrings to describe the arguments to the function, and\nwhat it will return.\n\n\n\n\n## Selecting a subset\n\nNow that we can find books by the title name, we also want to find all books that\nwere released after a certain data.\n\n-   Create a function called `books_released_after` that takes two arguments: the\n    database to look through, and the year.\n-   This function should look through the database, if it finds a book that was\n    released after the year, it should add it to a list of books that is returned from\n    this function.\n-   Test this function by calling `books_released_after` with `db` and `1850`. This function\n    call should return a list containing three dictionaries. The first entry should be\n    'Moby Dick' and the section should be 'A Study in Scarlet', etc.\n\n\n\n\n## Updating our database\n\nOh no! 'Hitchhikers Guide to the Galaxy' was released in 1979 not 1879, there must\nhave been a typo. Let's create a function to update this.\n\n-   Create a function called `update`, that takes 5 arguments: 1) the database to\n    update, 2) the key of the value we want to update 3) the value we want to update it\n    to 4) the key we want to check to find out if we have the correct book and 5) the\n    value of the key to check if we have the correct book.\n    \n        update(db,\n               key=\"release year\",\n               value=1979,\n               where_key=\"title\",\n               where_value=\"Hitchhikers Guide to the Galaxy\")\n\n\n\n\n## Extended exercise {.scrollable .smaller}\n\n-   In the previous steps we created functions `locate_by_title` and\n    `books_released_after`. These two functions are similar in a way that they are\n    selecting a subset of our database (just by different criteria).\n-   For this harder exercise, can we create a single function called `query` that allows\n    us to do both `locate_by_title` and `books_released_after`.\n-   An example call to this `query` function may look like:\n    \n        results = query(db,\n                        where_key=\"title\",\n                        where_value=\"Moby Dick\",\n                        where_qualifier=\"exactly\")\n\n-   `where_qualifier` should accept strings like `\"exactly\"`, `\"greater than\"`, and `\"less\n      than\"`.\n\n","srcMarkdownNoYaml":"\n\n![](./images/python-objects.png)\n\n# Python\n\n-   Python is a *high-level* programming language created in 1991.\n-   While it is an old language, its become vastly popular thanks to its use in data\n    science and other mathematics-based disciplines. While also being able to perform\n    tasks such as GUI, web-development and much more.\n-   Because the language is high-level and *interpreted*, programmers can often find\n    themselves more productive in Python than in other languages such as say C++.\n\n\n## A first program\n\nWe're going to start with the 'Hello, World' program that prints `Hello, World!` to the\nscreen. In python this is as simple as writing:\n\n```python\n    print(\"Hello, World!\")   # this prints: Hello, World!\n```\n\n    Results: \n    # => Hello, World!\n\n**NOTE** anything following a `#` is a comment and is completely ignored by the\ncomputer. It is there for you to document your code for others, and most\nimportantly, for yourself.\n\n## Running this program\n\nBefore we can run this program, we need to save it somewhere. For this, will\ncreate a new file, insert this text, and save it as `<filename>.py`, where\n`<filename>` is what we want to call the script. This name doesn't matter for its\nexecution.\n\nOnce we have created the *script*, we can run it from the *command line*. We will\nget into the command line in a later lecture, but right now all you need to know\nis:\n\n```bash\n    python3 <filename>.py\n```\n\n## An alternative method of running python\n\nYou may notice that if you don't give `python` a filename to run, you will enter\nsomething called the `REPL`.\n\n```\n    Python 3.9.5 (default, Jun  4 2021, 12:28:51) \n    [GCC 7.5.0] :: Anaconda, Inc. on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> \n```\n\n`REPL` stands for `READ`, `EXECUTE`, `PRINT`, `LOOP`.\n\n## Variables\n\nA *variable* is a *symbol* associated with a *value*. This value can differ widely, and we\nwill take a look at different types of values/data later.\n\nNeverthless, variables are useful for *referring* to values and *storing* to the results\nof a computation.\n\n```python\n    x = 1\n    y = 2\n    z = x + y\n    print(z)   # prints: 3\n    \n    # variables can be /overwritten/\n    z = \"hello, world\"\n    print(z)   # prints: hello, world\n```\n\n    Results: \n    # => 3\n    # => hello, world\n\n\n\n\n# Types of data\n\n\n## Primitive data types\n\nPrimitive data types are the most fundamental parts of programming, they cannot\nbe *broken* down.\n\n```python\n    \"Hello\" # string\n    1       # integer\n    1.0     # float\n    True    # Boolean (or bool for short)\n```\n\nWe can get the type of some data by using the `type(...)` function. For example,\n\n```python\n    print(type(5))\n    print(type(5.0))\n    \n    x = \"all cats meow\"\n    \n    print(type(x))\n```\n\n    Results: \n    # => <class 'int'>\n    # => <class 'float'>\n    # => <class 'str'>\n\n## Basic Math with primitives\n\nUsing these primitive data types, we can do some basic math operations!\n\n```python\n    print(1 + 2)    # Addtion\n    print(1 - 2)    # Subtraction\n    print(1 * 2)    # Multiplication\n    print(1 / 2)    # Division\n    print(2 ** 2)   # Exponent\n    print(3 % 2)    # Modulo operator\n```\n\n    Results: \n    # => 3\n    # => -1\n    # => 2\n    # => 0.5\n    # => 4\n    # => 1\n\nSometimes types get converted to the same type:\n\n```python\n    print(1.0 + 2)  # float + integer = float\n```\n\n    Results: \n    # => 3.0\n\nEven more interesting is with Booleans!\n\n```python\n    True + True\n```\n\n    Results: \n    # => 2\n\n## BODMAS in Python\n\nLike in mathematics, certain math operator take precedence over others.\n\n-   B - Brackets\n-   O - Orders (roots, exponents)\n-   D - division\n-   M - multiplication\n-   A - addition\n-   S - subtraction.\n\nTo make the context clear as to what operations to perform first, use brackets.\n\n```python\n    (5 / 5) + 1\n    5 / (5 + 1)\n```\n\n    Results: \n    # => 2.0\n    # => 0.8333333333333334\n\n## Basic Math &#x2013; Quick exercise\n\nWrite the following equation in python:\n\n$(5 + 2) \\times (\\frac{10}{2} + 10)^2$\n\n**Remember** to use parentheses `( )` to ensure that operations take precedence over\nothers.\n\nYour answer should come out as: `1575.0`\n\n# Working with Strings\n\n## Formatting strings\n\nIn many previous examples when we've printed strings, we've done something like:\n\n```python\n    age = 35\n    \n    print(\"The value of age is\", age)\n```\n\n    Results: \n    # => The value of age is 35\n\nWhile this works in this small context, it can get pretty cumbersome if we have many\nvariables we want to print, and we also want to change how they are displayed when\nthey are printed.\n\nWe're going to take a look now at much better ways of printing.\n\n\n## Better ways of printing strings - %\n\nThe first method is using `%`. When we print, we first construct a string with special\ndelimiters, such as `%s` that denotes a string, and `%d` that denotes a number. This is\ntelling Python where we want the values to be placed in the string.\n\nOnce we've created the string, we need to specify the data, which we do with `%\n(...)`. Like, for example:\n\n```python\n    age = 35\n    name = \"John\"\n    \n    print(\"%d years old\" % age)  # no tuple for one variable\n    print(\"%s is %d years old\" % (name, age)) \n```\n\n    Results: \n    # => 35 years old\n    # => John is 35 years old\n\nHere we are specifying the a string `%s` and number `%d`, and then giving the variables\nthat correspond with that data type.\n\nThe special delimiters correspond with a data type. Here are some of the most common:\n\n-   `%s` &#x2013; For strings\n-   `%d` &#x2013; For numbers\n-   `%f` &#x2013; For floating point numbers.\n\nThere are others such as `%x` that prints the hexadecimal representation, but these are\nless common. You can find the full list at: <https://docs.python.org/3/library/stdtypes.html#old-string-formatting>\n\nWhen using these delimiters, we can add modifiers to how they format and display the\nvalue. Take a very common example, where we have a floating point value, and, when\nprinting it, we only want to print to 3 decimal places. To accomplish this, we again\nuse `%f` but add a `.3` to between the `%` and `f`. In this example, we are printing &pi; to 3\ndecimal places.\n\n```python\n    print(\"Pi to 3 digits is: %.3f\" % 3.1415926535)\n```\n\n    Results: \n    # => Pi to 3 digits is: 3.142\n\nIn the previous example, we used `.3` to specify 3 decimal places. If we put a number\nbefore the decimal, like `10.3` we are telling Python *make this float occupy 10 spaces\nand this float should have 3 decimal places printed*.  When it gets printed, you will\nnotice that it shifts to the right, it gets padded by space. If we use a negative\nnumber in front of the decimal place, we are telling python to shift it to the left.\n\n```python\n    print(\"Pi to 3 digits is: %10.3f\" % 3.1415926535)\n    print(\"Pi to 3 digits is: %-10.3f\" % 3.1415926535)\n```\n\n    Results: \n    # => Pi to 3 digits is:      3.142\n    # => Pi to 3 digits is: 3.142\n\n\nThe final method of formatting strings is a newcomer within the language, it is the\nso-called `f-string`. Where a `f` character is prefixed to the beginning of the string\nyou're creating. `f-string`'s allow you to use Python syntax within the string (again\ndelimited by `{}`.\n\nTake this for example where we are referencing the variables `name` and `age` directly.\n\n```python\n    name = \"Jane\"\n    age = 35\n\n    print(f\"{name} is {age} years old\")\n```\n\n    Results: \n    # => Jane is 35 years old\n\n`f-string`'s allow you to execute Python code within the string. Here we are accessing\nthe value from the dictionary by specifying the key within the string itself! It\ncertainly makes it a lot easier, especially if we only need to access the values for\nthe string itself.\n\n```python\n    contact_info = {\"name\": \"Jane\", \"age\": 35}\n    \n    print(f\"{contact_info['name']} is {contact_info['age']} years old\")\n```\n\n    Results: \n    # => Jane is 35 years old\n\n<https://pyformat.info/>\n\nWe can still format the values when using `f-string`. The method is similar to those\nusing the `%f` specifiers.\n\n```python\n    pi = 3.1415926535\n    print(f\"Pi is {pi:.3f} to 3 decimal places\")\n```\n\n    Results: \n    # => Pi is 3.142 to 3 decimal places\n\nMany more examples can be found at: <https://zetcode.com/python/fstring/>\n\n## Splitting strings\n\nApart from formatting, there are plenty more operations we can perform on strings. We\nare going to highlight some of the most common here.\n\nThe first we're going to look at is splitting a string by a delimiter character using\nthe `.split()` method. If we don't pass any argument to the `.split()` method, then by\ndefault, it will split by spaces. However, we can change this by specifying the\ndelimiter.\n\n```python\n    my_string = \"This is a sentence, where each word is separated by a space\"\n    \n    print(my_string.split())\n    print(my_string.split(\",\"))\n```\n\n    Results: \n    # => ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n    # => ['This is a sentence', ' where each word is separated by a space']\n\n## Joining strings together\n\nAs `.split()` splits a single string into a list, `.join()` joins a list of strings into\na single string. To use `.join()`, we first create a string of the delimiter we want to\nuse to join the list of strings by. In this example we're going to use `\"-\"`. Then we\ncall the `.join()` method, passing the list as an argument.\n\nThe result is a single string using the delimiter to separate the items of the list.\n\n```python\n    x = ['This', 'is', 'a', 'sentence,', 'where', 'each', 'word', 'is', 'separated', 'by', 'a', 'space']\n    \n    print(\"-\".join(x))\n```\n\n    Results: \n    # => This-is-a-sentence,-where-each-word-is-separated-by-a-space\n\n## Changing cases\n\nOther common operations on strings involve change the case. For example:\n\n-   Make the entire string uppercase or lowercase\n-   Making the string title case (every where starts with a capital letter).\n-   Stripping the string by removing any empty spaces either side of the string.\n\n**Note** we can chain many methods together by doing `.method_1().method_2()`, but only if they\nreturn string. If they return `None`, then chaining will not work.\n\n```python\n    x = \"    this String Can change case\"\n    \n    print(x.upper())\n    print(x.lower())\n    print(x.title())\n    print(x.strip())\n    print(x.strip().title())\n```\n\n    Results: \n    # =>     THIS STRING CAN CHANGE CASE\n    # =>     this string can change case\n    # =>     This String Can Change Case\n    # => this String Can change case\n    # => This String Can Change Case\n\n\n## Replacing parts of a string\n\nTo replace a substring, we use the `.replace()` method. The first argument is the old\nstring you want to replace. The second argument is what you want to replace it with.\n\n```python\n    x = \"This is a string that contains some text\"\n    \n    print(x.replace(\"contains some\", \"definitely contains some\"))\n```\n    Results: \n    # => This is a string that definitely contains some text\n\n# Compound data structures\n\n## Container data types/Data structures\n\nContainer data types or data structures, as the name suggests, are used to contain\nother things. Types of containers are:\n\n-   Lists\n-   Dictionaries\n-   Tuples\n-   Sets\n\n```python\n    [1, \"hello\", 2]                 # list\n    {\"my-key\": 2, \"your-key\": 1}    # dictionary (or dict)\n    (1, 2)                          # tuple\n    set(1, 2)                       # set\n```\n\nWe'll take a look at each of these different container types and explore why we\nmight want to use each of them.\n\n\n\n\n## An aside on Terminology\n\nTo make our explanations clearer and reduce confusion, each of the different symbols\nhave unique names.\n\nI will use this terminology consistently throughout the course, and it is common to\nsee the same use outside the course.\n\n-   `[ ]` brackets (square brackets).\n-   `{ }` braces (curly braces).\n-   `( )` parentheses.\n\n\n## Lists\n\nA hetreogenious container. This means that it can store any type of data.\n\n```python\n    x = [1, \"hello\", 2]\n```\n\nElements can be accessed using indexing `[ ]` notation. For example:\n\n```python\n    print(x[0])    # this will get the first element (i.e. 1)\n    print(x[1])    # the second element (i.e. \"hello\")\n    print(x[2])    # the third element (i.e. 2)\n```\n\n    Results: \n    # => 1\n    # => hello\n    # => 2\n\n**notice how the first element is the 0-th item in the list/** we say that python is\n0-indexed.\n\n\n\n\n## Slices\n\nIf we wanted to access an element from a data structure, such as a list, we would use\nthe `[ ]` accessor, specifying the index of the element we wish to retrieve (remember\nthat indexes start at zero!). But what if we ranted to access many elements at once?\nWell to accomplish that, we have a slice or a range of indexes (not to be confused\nwith the `range` function). A slice is defined as:\n\n    start_index:end_index\n\nwhere the `end_index` is non inclusive &#x2013; it doesn't get included in the result. Here\nis an example where we have a list of 6 numbers from 0 to 5, and we slice the list from index\n0 to 3. Notice how the 3rd index is not included.\n\n```python\n    x = [0, 1, 2, 3, 4, 5]\n    print(x[0:3])\n```\n\n    Results: \n    # => [0, 1, 2]\n\n\n\n\n## Ranges\n\nWhen we use `start_index:end_index`, the slice increments by 1 from `start_index` to\n`end_index`. If we wanted to increment by a different amount we can use the slicing\nform:\n\n    start_index:end_index:step\n\nHere is an example where we step the indexes by 2:\n\n```python\n    x = list(range(100))\n    print(x[10:15:2])\n```\n\n    Results: \n    # => [10, 12, 14]\n\n\n\n\n## Reverse\n\nOne strange fact about the step is that if we specify a negative number for the step,\nPython will work backwards, and effectively reverse the list.\n\n```python\n    x = list(range(5))\n    \n    print(x[::-1])\n```\n\n    Results: \n    # => [4, 3, 2, 1, 0]\n\n\nIn a previous example, I created a slice like `0:3`. This was a little wasteful as we\ncan write slightly less code. If we write `:end_index`, Python assumes and creates a\nslice from the first index (0) to the `end_index`. If we write `start_index:`, Python\nassumes and creates a slice from `start_index` to the end of the list.\n\n```python\n    x = list(range(100))\n    \n    print(x[:10])\n    print(x[90:])\n```\n\n    Results: \n    # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # => [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n\n## Indexing backwards\n\nFinally, we also work backwards from the end of list. If we use a negative number,\nsuch as -1, we are telling Python, take the elements from the end of the list. -1 is\nthe final index, and numbers lower than -1 work further backwards through the list.\n\n```python\n    x = list(range(100))\n    \n    print(x[-1])\n    print(x[-2])\n```\n\n    Results: \n    # => 99\n    # => 98\n\nSlicing with negative indexes, also works. Here we are creating a slice from the end\nof the list - 10, to the last (but not including) index.\n\n```python\n    x = list(range(100))\n    \n    print(x[-10:-1])\n```\n\n    Results: \n    # => [90, 91, 92, 93, 94, 95, 96, 97, 98]\n\n\n## Adding data to a list\n\nIf we want to add items to the end of the list, we use the `append` function:\n\n```python\n    my_list = []\n    \n    my_list.append(\"all\")\n    my_list.append(\"dogs\")\n    my_list.append(\"bark\")\n    \n    print(my_list)\n```\n\n    Results: \n    # => ['all', 'dogs', 'bark']\n\n\n## Dictionaries\n\nDictionaries are a little different from lists as each 'element' consists of a\nkey-pair value. Let's have a look at some examples where the dictionaries contains\n**one** element:\n\n```python\n    my_dictionary = {\"key\": \"value\"}\n    my_other_dict = {\"age\": 25}\n```\n\nTo access the *value*, we get it using `[key]` notation:\n\n```python\n    my_other_dict[\"age\"]\n```\n\n    Results: \n    # => 25\n\n**NOTE** keys are unique, i.e:\n\n```python\n    my_dictionary = {\"age\": 25, \"age\": 15}\n    my_dictionary[\"age\"]\n```\n\n    Results: \n    # => 15\n\nThe key in the dictionary doesn't necessarily need to be a string. For example, in\nthis case, we have created two key-pair elements, where the keys to both are tuples\nof numbers.\n\n```python\n    my_dictionary = {(1, 2): \"square\", (3, 4): \"circle\"}\n    \n    print(my_dictionary[(1, 2)])\n```\n\n    Results: \n    # => square\n\n### adding data\n\nIf we want to add data to a dictionary, we simply perform the accessor method with a\nkey that is not in the dictionary:\n\n```python\n    my_dict = {}\n    \n    my_dict[\"name\"] = \"James\"\n    my_dict[\"age\"] = 35\n    \n    print(my_dict)\n```\n\n    Results: \n    # => {'name': 'James', 'age': 35}\n\n\n\n\n### Quick Exercise\n\n-   Create a dictionary for the following address, and assign it a variable name\n    called `address`:\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">Key</th>\n<th scope=\"col\" class=\"org-left\">Value</th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td class=\"org-left\">number</td>\n<td class=\"org-left\">22</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">street</td>\n<td class=\"org-left\">Bakers Street</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">city</td>\n<td class=\"org-left\">London</td>\n</tr>\n</tbody>\n</table>\n\n-   Print out the address's street name using the `[ ]` accessor with the correct key.\n\n\n\n\n## Tuples\n\n```python\n    my_tuple = (1, 56, -2)\n```\n\nLike lists, elements of the tuple can be accessed by their position in the list,\nstarting with the 0-th element:\n\n```python\n    print(my_tuple[0])  # => 1\n    print(my_tuple[1])  # => 56\n    print(my_tuple[2])  # => -2\n```\n\n    Results: \n    # => 1\n    # => 56\n    # => -2\n\nUnlike lists, tuples cannot be changed after they've been created. We say they are\n**immutable**. So this will **not** work:\n\n```python\n    my_tuple[2] = \"dogs\"  # creates an Error\n```\n\n    Results: \n    # => Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"/tmp/pyKdIIcx\", line 18, in <module>\n      File \"<string>\", line 1, in <module>\n    TypeError: 'tuple' object does not support item assignment\n\n\n\n\n## Sets\n\nSets in Python are like tuples, but contain only unique elements.\n\nYou can use the `set( )` function (**more on functions later!**), supplying a list, to create a set:\n\n```python\n    my_set = set([1, 2, 2, 2, 3, 4])\n    my_set\n```\n\n    Results: \n    # => {1, 2, 3, 4}\n\nNotice how there is only one '2' in the resulting set, duplicate elements are removed.\n\n\n\n\n### adding data\n\nIf we want to add data to a set, we use the `.add()` method. The element used as an\nargument to this function will only be added to the set if it is not already in the\nset.\n\n```python\n    my_set = set([])\n    \n    my_set.add(1)\n    my_set.add(2)\n    my_set.add(1)\n    \n    print(my_set)\n```\n\n    Results: \n    # => {1, 2}\n\n\n\n\n# Conditional expressions\n\n\n## If statement\n\nIf statements allow for branching paths of execution. In other words, we can execute\nsome statements if some conditions holds (or does not hold).\n\nThe structure of a simple if statement is:\n\n    if <condition>:\n        <body>\n\n```python\n    x = 2\n    y = \"stop\"\n    \n    if x < 5:\n        print(\"X is less than five\")\n    if y == \"go\":\n        print(\"All systems go!!\")\n```\n\n    Results: \n    # => X is less than five\n\nIn the previous example, the first `print` statement was only executed if the `x < 5`\nevaluates to `True`, but in python, we can add another *branch* if the condition\nevaluates to `False`. This branch is denoted by the `else` keyword.\n\n```python\n    x = 10\n    \n    if x < 5:\n        print(\"X is less than five\")\n    else:\n        print(\"X is greater than or equal to five\")\n```\n\n    Results: \n    # => X is greater than or equal to five\n\n\n## does it contain a substring?\n\nWe can check if a string exists within another string using the `in` keyword. This\nreturns a Boolean value, so we can use it as a condition to an `if` statement.\n\n```python\n    x = \"This is a string that contains some text\"\n    \n    if \"text\" in x:\n        print(\"It exists\")\n```\n\n    Results: \n    # => It exists\n\n## If statement &#x2013; Quick Exercise\n\n-   Create a variable called `age` and assign the value of this variable `35`.\n-   Create and `if` statement that prints the square of `age` if the value of `age` is more\n    than 24.\n-   This if statement should have an else condition, that prints `age` divided by 2.\n-   What is the printed value?\n\n\n## Multiple paths\n\nIf we wanted to add multiple potential paths, we can add more using the `elif\n<condition>` keywords.\n\nNote: The conditions are checked from top to bottom, only executing the else if none\nevaluate to `True`. The first condition that evaluates to `True` is executed, the rest\nare skipped.\n\n    x = 15\n    \n    if x < 5:\n        print(\"X is less than five\")\n    elif x > 10:\n        print(\"X is greater than ten\")\n    else:\n        print(\"X is between five and ten\")\n\n    Results: \n    # => X is greater than ten\n\n\n## Inline if-statements\n\nSometimes, we might want to conditionally set a variable a value. For this, we can\nuse an *inline* if statement. The form of an inline if statement is:\n\n`<value-if-true> if <condition> else <value-if-false>`\n\n    x = 10\n    \n    y = 5 if x > 5 else 2\n    \n    print(x + y)\n\n    Results: \n    # => 15\n\n\n## Boolean Logic\n\nAs we've seen, `if` statements are checking for conditions to evaluate to `True` or\n`False`. In python we use various comparison operators to check for conditions that\nevaluate to `Booleans`.\n\n### Comparison operators\n\n-   `<` less than\n-   `<=` less than or equal to\n-   `>` greater than\n-   `>=` greater than or equal to\n-   `==` is equal to\n-   `not` negation\n\nIf we want to check for multiple conditions, we can use conjunctives or disjunctive\noperators to combine the Boolean formulas.\n\nConjunctives/Disjunctives\n\n-   `and` all boolean expressions must evaluate to true\n-   `or` only one expression needs to be true\n\n\n\n\n### Not\n\nUsing `not` you can invert the Boolean result of the expression.\n\n    print(not True)\n\n    Results: \n    # => False\n\n    x = 10\n    \n    if not x == 11:\n        print(\"X is not 11\")\n\n    Results: \n    # => X is not 11\n\n\n\n\n### And\n\nLet's take an example using the `and` keyword. `and` here is checking that `x` is above or\nequal to 10 **and** `y` is exactly 5. If either of the conditions is `False`, python will\nexecute the `else` path (if there is one, of course!).\n\n    x = 10\n    y = 5\n    \n    if x >= 10 and y == 5:\n        z = x + y\n    else:\n        z = x * y\n    \n    print(z)\n\n    Results: \n    # => 15\n\n\n\n\n### Or\n\nHere we see the use of the `or` keyword. If any of the conditions evaluates to `True`\nthen the whole condition evaluates to `True`.\n\n    x = 10\n    y = 5\n    \n    if x < 5 or y == 5:\n        print(\"We got here!\")\n    else:\n        print(\"We got here instead...\")\n\n    Results: \n    # => We got here!\n\nNote: `or` is short-circuiting. This means that if tests the conditions left-to-right,\nand when it finds something that is `True` it stops evaluating the rest of the\nconditions.\n\n    x = 10\n    \n    if x < 20 or print(\"We got to this condition\"):\n        print(\"The value of x is\", x) \n\n    Results: \n    # => The value of x is 10\n\n\n\n\n### Combining And and Or\n\nIf your Boolean logic refers to a single variable, you can combine the logic without\nthe `and` and `or`. But its not always common.\n\nFor example,\n\n    x = 7\n    \n    if x < 10 and x > 4:\n        print(\"X is between 5 and 10\")\n\nCan be the same as:\n\n    x = 7\n    \n    if 5 < x < 10:\n        print(\"X is between 5 and 10\")\n\n    Results: \n    # => X is between 5 and 10\n\n\n\n\n# Iteration\n\n\n\n## For loop\n\nLooping or iteration allows us to perform a series of actions multiple times. We are\ngoing to start with the more useful `for` loop in python. The syntax of a `for` loop is:\n\n    for <variable_name> in <iterable>:\n        <body>\n\n    for i in range(3):\n        print(i)\n\n    Results: \n    # => 0\n    # => 1\n    # => 2\n\n\n\n\n## break\n\nThe previous example loops over the body a fix number of times. But what if we wanted\nto stop looping early? Well, we can use the `break` keyword. This keyword will exit the\nbody of the loop.\n\n    for i in range(10):\n        if i > 5:\n            break\n        print(i)\n\n    Results: \n    # => 0\n    # => 1\n    # => 2\n    # => 3\n    # => 4\n    # => 5\n\n\n\n\n## continue\n\nA different keyword you might want to use is `continue`. Continue allows you to move/skip\nonto the next iteration without executing the entire body of the `for` loop.\n\n    for i in range(10):\n        if i % 2 == 0:\n            continue\n        print(i)\n\n    Results: \n    # => 1\n    # => 3\n    # => 5\n    # => 7\n    # => 9\n\n\n\n\n## ranges\n\nInstead of using `continue` like in the previous slide, the `range` function provides us\nwith some options:\n\n`range(start, stop, step)`\n\nIn this example, we are starting our iteration at 10, ending at 15, but stepping the\ncounter 2 steps.\n\n    for i in range(10, 15, 2):\n        print(i)\n\n    Results: \n    # => 10\n    # => 12\n    # => 14\n\n\n\n\n## Loop over collections\n\nFor loops allow us to iterate over a collection, taking one element at a time. Take\nfor example, a list, and for every item in the list we print its square.\n\n    my_list = [1, 5, 2, 3, 5.5]\n    \n    for el in my_list:\n        print(el**2)\n\n    Results: \n    # => 1\n    # => 25\n    # => 4\n    # => 9\n    # => 30.25\n\n\nThis kind of looping can work for tuples and sets, but as we have seen, dictionaries\nare a little different. Every 'element' in a dictionary consists of a key and a\nvalue. Therefore when we iterate over items in a dictionary, we can assign the key\nand value to different variables in the loop.\n\n**Note** the use of the `.items()` after the dictionary. We will explore this later.\n\n    my_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n    \n    for el_key, el_val in my_dict.items():\n        print(\"Key is:\", el_key, \" value is: \", el_val)\n\n    Results: \n    # => Key is: name  and the value is:  jane\n    # => Key is: age  and the value is:  35\n    # => Key is: location  and the value is:  France\n\nWe could also loop over the keys in the dictionary using the `.keys()` method instead\nof `.items()`.\n\n    my_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n    \n    for the_key in my_dict.keys():\n        print(the_key)\n\n    Results: \n    # => name\n    # => age\n    # => loc\n\nOr, the values using `.values()`.\n\n    my_dict = {\"name\": \"jane\", \"age\": 35, \"loc\": \"France\"}\n    \n    for the_value in my_dict.values():\n        print(the_value)\n\n    Results: \n    # => jane\n    # => 35\n    # => France\n## List comprehensions\n\nWe have seen previously how `for` loops work. Knowing the syntax of a `for` loop and\nwanting to populate a list with some data, we might be tempted to write:\n\n    x = []\n    for i in range(3):\n        x.append(i)\n    \n    print(x)\n\n    Results: \n    # => [0, 1, 2]\n\nWhile this is perfectly valid Python code, Python itself provides 'List\ncomprehensions' to make this process easier.\n\n    x = [i for i in range(3)]\n\n\nThe syntax of a list comprehensions is:\n\n    [ <variable> for <variable> in <iterable> ]\n\nWe can also perform similar actions with a dictionary\n\n    [ <key>, <value> for <key>, <value> in <dictionary.items()> ]\n\n\n\n\n### using `if`'s\n\nPerhaps we only want to optionally perform an action within the list comprehension?\nPython allows us to do this with the inline `if` statement we've seen in the previous lecture.\n\n    x = [i if i < 5 else -1 for i in range(7)]\n    print(x)\n\n    Results: \n    # => [0, 1, 2, 3, 4, -1, -1]\n\nWe add the inline `<var> if <condition> else <other-var>` before the `for` loop part of\nthe comprehension.\n\nThere is another type of `if` statement in a list comprehension, this occurs when we\ndon't have an `else`.\n\n    x = [i for i in range(7) if i < 3]\n    print(x)\n\n    Results: \n    # => [0, 1, 2]\n\nIn this example, we're only 'adding' to the list if the condition ($i < 3$) is true,\nelse the element is not included in the resulting list.\n\n### multiple `for`'s\n\nIf we like, we can also use nested for loops by simply adding another for loop into\nthe comprehension.\n\n    x = [(i, j) for i in range(2) for j in range(2)]\n    \n    print(x)\n\n    Results: \n    # => [(0, 0), (0, 1), (1, 0), (1, 1)]\n\nIn this example, we're creating a tuple for each element, effectively each\ncombination of 1 and 0.\n\n\n\n\n## List comprehensions with dictionary\n\nPython doesn't restrict us to list comprehensions, but we can do a similar\noperation to create a dictionary.\n\n    x = [2, 5, 6]\n    y = {idx: val for idx, val in enumerate(x)}\n    print(y)\n\n    Results: \n    # => {0: 2, 1: 5, 2: 6}\n\nHere, every item in `x` has been associated with its numerical index as a key thanks to\nthe `enumerate` function that returns both the index and value at iteration in the for loop.\n\n## For loop &#x2013; Quick Exercise\n\n-   Create a list of elements:\n    -   2\n    -   \"NA\"\n    -   24\n    -   5\n\n-   Use a `for` loop to iterate over this list.\n-   In the body of the `for` loop, compute $2x + 1$, where $x$ is the current element of\n    the list.\n-   Store the result of this computation in a new variable $y$, and then print y.\n\n**Note** You cannot compute $2x + 1$ of \"NA\", therefore you will to use an `if` statement\nto skip onto the next iteration if it encounters this. **Hint** try: `type(...) =!=` `str`\n\n## While loop\n\nA `while` loop is another looping concept like `for` but it can loop for an arbitrary\namount of times. A `while` loop looks to see if the condition is `True`, and if it is, it\nwill execute the body.\n\nThe syntax of the while loop is:\n\n    while <condition>:\n        <body>\n\n    i = 0\n    \n    while i < 3:\n        print(i)\n        i = i + 1\n\n    Results: \n    # => 0\n    # => 1\n    # => 2\n\n    x = 0\n    y = 1\n    \nHere is another example:\n\n    while x + y < 10:\n        print(\"X is,\", x, \"and y is\", y)\n        x = x + 1\n        y = y * 2\n    \n    print(\"X ended as\", x, \", while y is\", y)\n\n    Results: \n    # => X is, 0 and y is 1\n    # => X is, 1 and y is 2\n    # => X is, 2 and y is 4\n    # => X ended as 3 , while y is 8\n\n# Functions\n\nFunctions are a re-usable set of instructions that can take some arguments and\npossible return something.\n\nThe basic structure of a function is as follows:\n\n    def <function_name>(args*):\n        <body>\n        (optional) return\n\n-   `args*` are 0 to many comma separated symbols.\n-   `body` is to be indented by 4 spaces.\n\nThis is only the function *definition* however. To make it do something, we must *'call'*\nthe function, and supply the arguments as specified in the definition.\n\n    def say_hello():   # function definition\n        print(\"Hello, World!\")\n    \n    say_hello()  # calling the function\n\nWe've already seen some functions provided by Python.\n\n`print` itself is a function with a single argument: what we want to print.\n\n    print(\"Hello, World!\")\n    # ^         ^\n    # |         |\n    # | user supplied argument\n    # |\n    # function name \n\n`set` is another function that takes a single argument: a collection of data with which\nto make a set:\n\n    set([1, 2, 2, 3, 4])\n\n\n## Example usage of a function\n\nLet's make a function that takes two numbers and adds them together:\n\n    def my_addition(a, b):\n        result = a + b\n        return result\n    \n    x = 2\n    y = 3\n    z = my_addition(2, 3)  # return 5 and stores in z\n    print(z)\n\n    Results: \n    # => 5\n\n\n## Quick exercise\n\n-   Create a function called `my_square`. This function should take one argument (you can\n    call this argument what you like).\n-   The body of the function should compute and return the square of the argument.\n-   Call this function with `5.556`.\n-   Store the result of calling this function, and print it.\n-   What is the result?\n\n## Re-usability with Functions\n\nFunctions are better illustrated through some examples, so let's see some!\n\n    name_1 = \"john\"\n    name_2 = \"mary\"\n    name_3 = \"michael\"\n    \n    print(\"Hello \" + name_1 + \", how are you?\")\n    print(\"Hello \" + name_2 + \", how are you?\")\n    print(\"Hello \" + name_3 + \", how are you?\")\n\nThe above is pretty wasteful. Why? Because we are performing the exact same\noperation multiple times, with only the variable changed.\n\nBy abstracting the actions we want to perform into a function, we can ultimately\nreduce the amount of code we write. *Be a lazy programmer!*\n\n    name_1 = \"john\"\n    name_2 = \"mary\"\n    name_3 = \"michael\"\n    \n    def say_hello(name):\n        print(\"Hello \" + name + \", how are you?\")\n    \n    say_hello(name_1)\n    say_hello(name_2)\n    say_hello(name_3)\n\nIn this example, we've used the function as defined with the `def` pattern to write\nthe `print` statement once. Then, we've called the function with each variable as its\nargument.\n\n## Named parameters\n\nWe've seen in previous examples that, when we create a function, we give each of the\narguments (if there are any) a name.\n\nWhen calling this function, we can specify these same names such as:\n\n    def say_hello(name):\n        print(\"Hello,\", name)\n    \n    say_hello(\"Micheal\")\n    say_hello(name=\"Micheal\")\n\n    Results: \n    # => Hello, Micheal\n    # => Hello, Micheal\n\nBy specifying the name of the parameter we're using with the called function, we can\nchange the order\n\n    def say_greeting(greeting, name):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(name=\"John\", greeting=\"Hi\")\n\n    Results: \n    # => Hi John I hope you're having a good day\n\n## Optional/Default/Positional arguments\n\nWhen we call a function with arguments without naming them, we are supplying them by\n*position*.\n\n    def say_greeting(greeting, name):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(#first position, #section position)\n\nThe first position gets mapped to variable name of `greeting` inside the body of the\n`say_greeting` function, while the second position gets mapped to `name`. \n\nSometimes when creating a function we may want to use default arguments, these are\narguments that are used if the call to the function does not specify what their value\nshould be. For example.\n\n    def say_greeting(name, greeting=\"Hello\"):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(\"John\")\n    say_greeting(\"John\", \"Hi\")  # supply greeting as positional argument\n\n    Results: \n    # => Hello John I hope you're having a good day\n    # => Hi John I hope you're having a good day\n\n**Note** if you supply a default argument in the function definition, all arguments after\nthis default argument must also supply a default argument.\n\nSo, this **won't** work:\n\n    def say_greeting(name=\"Jane\", greeting):\n        print(greeting, name, \"I hope you're having a good day\")\n    \n    say_greeting(\"John\", \"Hi\")\n\n\n## Recap on arguments\n\n    # defining the function\n    \n    def say_greeting(name, greeting)  # no default arguments\n    def say_greeting(name, greeting=\"Hello\")  # greeting is a default argument\n    def say_greeting(name=\"Jane\", greeting=\"Hello\")  # both arguments have a default\n    \n    # calling the functions\n    \n    say_greeting(\"John\", \"Hi\")  # both arguments are provided by position\n    say_greeting(name=\"John\", greeting=\"Hi\")  # arguments are supplied by name\n    say_greeting(greeting=\"Hi\", name=\"John\")  # the position of named arguments do not matter\n\n## Function doc-strings\n\nTo make it clear for a human to quickly understand what a function is doing, you can\nadd an optional doc-string. This is a string that is added directly after the initial\ndefinition of the function:\n\n    def my_function(x, y):\n        \"\"\"I am a docstring!!!\"\"\"\n        return x + y\n\nSome common use cases for docstrings are explaining what the parameters are that it\nexpects, and what it returns.\n\nIf your explanation is a little longer than a line, a multiline docstring can be\ncreated as long as you're using `\"\"\"` three quotation marks either side of the string\n\n    def my_function(x, y):\n        \"\"\"\n        This is my realllly long docstring\n        that explains how the function works. But sometimes\n        its best not to explain the obvious\n        \"\"\"\n        return x + y\n\n## Understanding scope\n\nIn this example we have two scopes which can be easily seen by the indentation. The\nfirst is the *global* scope. The second scope is the scope of the function. The scope\nof the function can reference variables in the larger scope. But once the function\nscope exits, we can no longer reference the variables from the function.\n\n    x = 10\n    \n    def compute_addition(y):\n        return x + y\n    \n    print(compute_addition(10))\n    print(x)\n    print(y)  # does not work\n\n    Results: \n    # => 20\n    # => 10\n\nEven though we can reference the global scope variable from the scope of the\nfunction, we can't modify it like this:\n\n    x = 10\n    \n    def compute_addition_2(y):\n        x = x + 5  # error local variable referenced before assignment\n        return x + y\n    \n    print(compute_addition_2(10))\n\nIf we really wanted to reference a variable in a global scope and modify its value,\nwe could use the `global` keyword. Doing this makes the\nfunction output something different every time it is called. This can make it\ndifficult to debug incorrect programs.\n\n    x = 10\n    \n    def compute_addition_2(y):\n        global x\n        x = x + 5\n        return x + y\n    \n    print(compute_addition_2(10))\n    print(x)\n    print(compute_addition_2(10))\n\n    Results: \n    # => 25\n    # => 15\n    # => 30\n\nIn almost all cases, avoid using global variables. Instead pass the variables as\nparameters. This can reduce a source of potential errors and ensure that if a\nfunction is called multiple times, the output can be more consistent and expected.\n\n    x = 10\n    \n    def compute_addition_3(x, y):\n        x = x + 5\n        return x + y\n    \n    print(compute_addition_3(x, 10))\n    print(x)\n    print(compute_addition_3(x, 10))\n\n    Results: \n    # => 25\n    # => 10\n    # => 25\n\n# Exercise\n\n## Library system\n\n\n\n\n## Use what you've learnt!\n\nWe're going to create a library system to help locate and lookup information about\nbooks. For example, we want to know the author of book called 'Moby Dick'.\n\nTo create this system, we are going to do it in stages. First, we will want to create\nour database of books:\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n\n<col  class=\"org-right\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-left\">Title</th>\n<th scope=\"col\" class=\"org-left\">Author</th>\n<th scope=\"col\" class=\"org-right\">Release Date</th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td class=\"org-left\">Moby Dick</td>\n<td class=\"org-left\">Herman Melville</td>\n<td class=\"org-right\">1851</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">A Study in Scarlet</td>\n<td class=\"org-left\">Sir Arthur Conan Doyle</td>\n<td class=\"org-right\">1887</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Frankenstein</td>\n<td class=\"org-left\">Mary Shelley</td>\n<td class=\"org-right\">1818</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">Hitchhikers Guide to the Galaxy</td>\n<td class=\"org-left\">Douglas Adams</td>\n<td class=\"org-right\">1879</td>\n</tr>\n</tbody>\n</table>\n\nOur database is going to be a list of dictionaries. Where each dictionary is a row\nfrom this table. For example, one of the dictionaries will have the key \"title\" and a\nvalue \"Moby Dick\".\n\nCreate this database and call it `db`.\n\n\n\n\n## Locating Books\n\n-   Create a function called `locate_by_title` that takes the database to look through,\n    and the title to look up as arguments.\n-   This function should check each dictionary, and if the title is the same as what\n    was searched for, it should return the whole dictionary.\n-   Test this function by calling the `locate_by_title` function with `db` and\n    `\"Frankenstein\"`. You should get `{\"title\": \"Frankenstein\", \"author\": ...}`.\n\n**Note** you should include docstrings to describe the arguments to the function, and\nwhat it will return.\n\n\n\n\n## Selecting a subset\n\nNow that we can find books by the title name, we also want to find all books that\nwere released after a certain data.\n\n-   Create a function called `books_released_after` that takes two arguments: the\n    database to look through, and the year.\n-   This function should look through the database, if it finds a book that was\n    released after the year, it should add it to a list of books that is returned from\n    this function.\n-   Test this function by calling `books_released_after` with `db` and `1850`. This function\n    call should return a list containing three dictionaries. The first entry should be\n    'Moby Dick' and the section should be 'A Study in Scarlet', etc.\n\n\n\n\n## Updating our database\n\nOh no! 'Hitchhikers Guide to the Galaxy' was released in 1979 not 1879, there must\nhave been a typo. Let's create a function to update this.\n\n-   Create a function called `update`, that takes 5 arguments: 1) the database to\n    update, 2) the key of the value we want to update 3) the value we want to update it\n    to 4) the key we want to check to find out if we have the correct book and 5) the\n    value of the key to check if we have the correct book.\n    \n        update(db,\n               key=\"release year\",\n               value=1979,\n               where_key=\"title\",\n               where_value=\"Hitchhikers Guide to the Galaxy\")\n\n\n\n\n## Extended exercise {.scrollable .smaller}\n\n-   In the previous steps we created functions `locate_by_title` and\n    `books_released_after`. These two functions are similar in a way that they are\n    selecting a subset of our database (just by different criteria).\n-   For this harder exercise, can we create a single function called `query` that allows\n    us to do both `locate_by_title` and `books_released_after`.\n-   An example call to this `query` function may look like:\n    \n        results = query(db,\n                        where_key=\"title\",\n                        where_value=\"Moby Dick\",\n                        where_qualifier=\"exactly\")\n\n-   `where_qualifier` should accept strings like `\"exactly\"`, `\"greater than\"`, and `\"less\n      than\"`.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"lecture-1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"yeti","smooth-scroll":true,"title":"Python Introduction","subtitle":"Lecture 1","author":"Jay Paul Morgan"},"extensions":{"book":{"multiFile":true}}},"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"lecture-1-reveal.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.3.450","auto-stretch":true,"theme":"serif","title":"Python Introduction","subtitle":"Lecture 1","author":"Jay Paul Morgan","scrollable":true,"smaller":false,"slideNumber":true,"navigationMode":"default","transition":"slide"}}},"projectFormats":["html","revealjs"]}